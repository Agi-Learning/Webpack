# Zack Jackson - Module Federation

* Hey, I'm Zach Jackson. I'm a principal engineer over at Lululemon and a big passionate developer in open source community. And, yeah, work with web pack a lot. And in the past couple months, I've been investing a lot more time in the webpack in general. And we have some new exciting things on the so Thanks for having me on. Yeah. So tell me about module federation and why? Why should we care about this? Yeah. So module

## What is Module Federation

* And why? Why should we care about this Yeah. So module federation is aimed at solving some general problems that I think we faced in the front end community for quite a long time now. I think anybody who's really worked with kind of distributed javascript apps or needing to deploy more than one app separately has run into this challenge. microfront ends is kind of the blanket term where it all kind of shows up all in one go. So what module federation aims to do is remove. the need for kind of this external system that you would have to put in place. So if we look at a practical example, you have a bunch of microfront ends or or apps that need to share something the best that we could ever do was really to share code. and that would involve making it external in all of your builds and then putting some centralized file on every app that's going to run whatever these dependencies are that are needed and that's just a very flimsy system in general, because when it comes to trying to upgrade something, how do you do a blanket roll out when certain teams aren't ready and also the file goes missing, you're completely dead in the water everywhere. So there's very little capability for redundancy, stuff like that. And it only really applies to vendor code in general. So it doesn't take into account how do we deal with things like you know, feature feature sharing or business logic sharing or some of those other things where development teams are working on it and you know there's their solutions to that as well. But all of them have these drawbacks, I think by and large, we're quite aware of having to do double deploys, publish something here, then turn around and redeploy the stack together. And in general, that'll just lead to fragmentation management overhead. And it's depending on the scale the company, you might even need a whole team just dedicated to something that really should just be a trivial non-issue. So I've got multiple teams, and one of them has this really cool product carousel on it. Is that something that I could use Module Federation to share with another team

## Sharing UI Code

* Yeah. So you could use module federation to share something such as that you could really share anything that exists in that repo with another team and it's Evergreen over the wire and There's considerations as well for server side rendering and stuff like that. So it really kind of encompasses the whole package. So you're not just stuck with, well, it works in the browser, but what about on the server or something like that? There's probably 1 or 2 drawbacks depending on how often the rate of change is to those components. And those are factors that we'll probably get into throughout this video when and when not to use it. Yeah, I was just gonna say so. Does it require that? both of those applications have the same versions of those underlying libraries So there's a few ways that you can break it down when it comes to, say, the vendor sharing aspect, which has also been a real tricky 1. And when you're trying to do an upgrade on a microfront stack, there's a lot of risk involved in trying to move major versions. Everybody has to do it all in one go. And even then, I'm sure that there's some disruption to the guest experience, because deployments just don't kick off all at once. And edge caches don't flush all at the same time. And if you're depending on these kind of external references, what happens when fragments of them start to disappear and become incompatible? So in the examples that we've put out on module federation, I've written a little article about it. We've kind of shown a very simple high level of how it's used and a lot of questions have come back around versioning and specific. And when it comes to vendor code, you'll. notice we have that little shared block in the plug-in configuration and that in all the examples that we've seen is just an array. So it's just react or react dumb or whatever you're trying to share. But there's actually a whole lot more power under the hood that we haven't really just revealed in the 1 or 2 articles that we've put out. So if you wanted to handle, say, multiple vendors or multiple vendor versions, but you want to have kind of this optimistic model where they can share when possible. what would be ideal is that I have a little bit more time and I can write a plugin that kind of automates that. But if you need it or wanted to do it today, you could do it with just a simple function that is attached onto that webpack config. So the easiest way to support, say, multiple vendors if you need it is you could have a loop that goes through your package JSON file and maybe you have a white list of some kind. So certain things that you intend on sharing whatever and you pull those packages. off of there and you resolve the actual installed version that's in your node module folder. So what you end up with and shared is this key value object where the key is react but the value is actually react .15 or .16 .8 dot whatever. So when it goes all the way into module federation and you're trying to share this between multiple run times, they're able to see hey do you have this specific alias key and if they do have them it will just share optimistically between it Now that also could kind of get into the space well, well, nobody has of the same version of everything like there's always a patch version or something different So what I'm pretty much doing is I just take it from the feature version. So I leave the fixed version alone. So if you're on react 16.8 .1 or 16 8.5 it's just going to go okay cold. They're both called 16.8. So if a 16.8 is available, use the host's version. If there's. 16.7 then maybe it needs to go and download its own copy. React obviously isn't the best use scenario because you can't really have multiple versions of react working together in one dependency graph. But if we took Mama J. S. Or redox, you know some some other dependency that doesn't have this specific multiple versions of react problem. If we just get to the feature version as long as the semantic versioning is followed and appeared to the. feature will not introduce any breaking changes. So the patches really won't matter because all of the features are still going to be there, which would allow the remote to then depend on the host version and the gut like a wider capability of sharing And then of course managing the dependencies in general. That's you know another whole side of things. But this comes down to kind of the implementation detail of it and that's something that isn't really a webpack concern per se. You can break your own web pack build and you know you can put 2 copies of react in and web pack will run it but the browser's not going to be very happy about it. So what we're getting into is this kind of discussion of where does the scope of what web pack does ends and where does implementation details begin and that's why the flexibility exists. But is that we don't just automatically do it because it's really not up to the compiler to decide how your your system should work But you know you can make it do that very easily and with renovate thought or you know something like that you'll end up getting everything more or less synced at least to the feature version which allows for optimistic coach and if somebody wants to go a little bit ahead of time run early and upgrade something no problem. no problem they get to upgrade they'll share it with anybody else who happen to pull that upgrade and every other application can still roll with a older version until they're ready for that update. So it really gives that flexibility to move without proposing a lot of risk to a wide scale at a big company. So it does sound like if you have a microsite architecture you each team is developing its own independent site that web pack 5 if you've got the right if you got feature level versioning locked in then potentially you can bring back a spa experience with module federation.

### Multi steam SPA

* Yeah. So that was actually the core reason that I kind of embarked off on this journey. It was really just out of frustration that you know, I think it was 2016 when I started doing a whole bunch of stuff with code splitting I revived the whole React Universal Library and that thing was kind of what kick started all the code split S. SR stuff. A lot of the mechanism still kind of use the same technology that we had put in there. But once we had code splitting and service side rendering working, it was really great. But there was. still this like last mile piece that was just not solved and it was the fact that I have to do a page refresh just to move and if you think. and if you think of Most microfronted apps, at least at the enterprise level, it's not so much about differing technologies as it is about organizational optimization of Development workflows and development release so you. usually end up with each of these projects installing like 80% of the same Independence is underneath them. Let's take an easy example next. JS, you got a bunch of next js microfront ends. What's most of the dependencies? It's almost exactly the same. A few French pieces here and there, but you're redownloading and having to pretty much reexecute reparse and just. do it the whole reboot just because you move to a different page and it just seemed like such a performance loss and such a bandwidth waste So I kind of set out thinking about it took a while, but eventually came up with a workable proof of concept and you know, eventually we got it into web pack and the premise of the idea was I don't want to reload my page when I go from microfronted 1 to microfronted 2 when there's no real need to do it nice and you mentioned S. S. R. So this all That still supports ssr, even with all that.

## Server Side Rendering

* Yeah. So the initial design that we have put together did not support ssr. And it kind of relied on merging dependency graphs and stuff like that. And it worked great in the browser. And for me, the browser was the main problem that we all face. That's where the UX impact comes in. So if I have to pay a little bit more on the CI side or on the upside, that's a little bit easier to kind of offload because we're very used to these kind of workflows anyway. So the first plan that I have had for this was, you know, we have the kind of Federated system in the front end, and you could use something like a post. call to the other microfront and have it do its render return. It's H. T. M. L. Maybe have a little react component or something that puts up string marker in there and you do a promise. I'll render your wrap and then a string replacement and header goes here. The footer goes there or whatever you want and kind of stitch it back together. But as this developed and moved into web pack we were able to unlock this to work with all the module types of web pack support. So the browser is just 1 and even the browser has 3 subsets of kind of types that you could have. You can have window you could have global and you can have var which is kind of just the standard 1 and it supports all of those plus it supports system J. S. It supports common JSA. M. D. U. M. D. You know the works. So what ended up happening was when we wrote all the tests for this and we were like O. K. Let's just flip this over with the common J. S1. and see how it runs. It works perfectly and the only real difference that you would have is inside of that remote object inside of the module federation plug-in Usually it's just a It'll take an array as well, but usually I show it as an object where it's just F1 F1. But in common JS for say service at rendering it would be like you know website one and the value of that key would be the path to go and find wherever this kind of common J. S. Remote entry was emitted every server has a server build and every client has a client build so all you really have to do is you know kind of dot dot slash dot dot slash server slash container. container.Js and what it'll end up doing is attaching itself exactly how it attaches it in the browser. Same api same use interface you know the works. It's all the same. the trick on how to actually run Federated server site code really comes down to the implementation details so if you're on say Kubernetes one of the easiest ways it would be to just have like a shared volume. So when you deploy everything out you could potentially just deploy the Federated parts out to a shared volume and you have the consumer or the host on the server side would just walk at the file system go and find it and require that container and from there everything is reconnected and reinterface just like how it would be in the browser for. say lambdas and a. W. S. A little bit more tricky but because the async note target on webpack is just AF. S. And V. M. All you really have to do is have like an abstraction layer around F. S so that you could stream the file buffers directly from S3 into the Lambda's. So now you can have Lambda's serverless all of that and they can just stream the remote entries directly into the file system on demand. Nice. So we've talked a little bit about like sharing react and I know we've kind of touched on this a little bit around. I mean but it is it's just Java scrolling and you can share any Java script. I mean what what can we think of using this for outside of my graph ease

## Sharing Non-UI Code

* Yeah, so I work and react a lot. So obviously react is like the go to case. Plus it's reactive. So it just makes it easier to explain concepts like set state is an amazing thing or do something and then set state so it shows up But the reality of it is is this is just a stock standard web pack functionality. So whatever web pack can process just plain old Java script completely not related to any kind of framework it will just work and I think one of the cool things is it's not only javascript that it handles it will handle all the loaders that you've got if you want to load images CSS anything like that it'll attach those loaders from the remote into the host and it will actually load others other files or side effects that typically you just couldn't share as easily like with external as you can't really do externals that can resolve images properly or resolve styles really well. It gets a little buggy but in this system it will just work to get to your question on other kind of use cases for this other. sharing feature code and react components and stuff like that which is great but you could go far beyond that and into things like well what about sharing configurations if you think about a typical build when you deploy something to AQ. A. Environment what's really changing there? It's probably an environment variable or some little config file and you kind of switch between the different configs yet we still redeploy it each time to promote it up the environment So Federation you could just have the config itself be Federated and recycle the build. So whatever you built in the QA environment which is you know built in production mode and what not all you have to do is federate the configuration in which you can contain your API endpoints and stuff like that and depending on environment you go to you just have this stuff attached and ready nice and so yeah, I like AB tests as well seems like maybe a natural fix of that

## A/B Testing

* Yeah, so the yes, so some other really cool examples beyond like configuration and things like that would be AB tests, which is I think a really great example in general because it's one of those things that has a hard separation between software engineering teams and say the marketing teams or the optimization teams who are really fine tuning the experience that you get in some cases you might Get Lucky and the teams control the A. B testing which makes things a little bit easier, but depending on the scale you're working at that can also get the way a product delivers and product owners aren't necessarily wanting to run 1015 different variations. They want to develop product the way that they see it and move on to the next product to keep the overall business moving forward. So AB testing you know we have tools out there now but they're very clunky compared to the general engineering flows that we're kind of used to those jobs for developers. If we look at say Google optimize or something like that what you mostly have to do is just paint vanilla Java script on top of the Dom and you have. to you have to use mutation observer or something so that every time there's a re render it will catch it and if that's not set up correctly and you just change some state your whole test goes away and either way you can't really build interactive tests or I would say probably the worst part of it is if you find a winner you have to then turn around and go to a product team and say hey I need you to rewrite the whole thing because we did it in some venila JS because that's all the tool can really offer you can't really kind of. you can't really use JSX inside Google Optimize or something you're limited to a primitive set and in some cases it's even a whizzy wave where you just click on things and change it and the amount of scripts that you end up dumping on the page and the rights to the dumb and that's all competing with react itself which is completely unaware of it. So it's just really AA very unreacting way or even if we don't think about react angular they use a virtual zombie everything's using virtual doms and it's very against the virtual Dom idea of mutating H. T. M. Without the actual system being aware. So with AB tests yeah it's fantastic because you could have a team where you just have been working in their own repo and as they make modifications or changes there's no need for double deploys or anything like that. You have some kind of little abstraction layer on the component if we're using react is a good example you would just have a special component that maybe assistance based or or something like that and it shows the default experience until it receives that the AB test control scenarios. However it does and at which case it will just pull in in real time at runtime either on the server or the client that AB test from a different leading deploy reba or separately deploy repo and you know that gives a ton of power because you can now start refining tuning editing these things without having to interfere with the general product flow and it's also not a big performance impact is actually less of a performance impact because you would have your team's writing real. react or real angular or view or whatever your framework is you're writing stuff that could just be proven out. This is the winner and then just drag and drop it right back into the core code base and deploy it to production as the real thing. And that's something that you really just can't get easily with what's on the market right now. Yeah, yeah, definitely. And I've seen at least my experience teams. other teams in the company are doing infrastructure level stuff around like analytics or vendor scripts. And it also seems like and I've seen those come in via just kind of script tag level stuff and and that can be little wonky. It's hard to test. This seems like a much cleaner way to bring in that kind of code.

## External Scripts

* Yeah, I definitely you could ramp this up to all sorts of other things. So I think one of the really exciting ones would be if we take a look at their traditional tag managers that we're all used to and those are kind of this ivory tower walled garden where you could do whatever you want and the the tag manager comes along and drops 7080 scripts on the page and doubles your T. T. I triples your TTI and there's just very little way for us to even integrate smoothly with it. If we do try to integrate with it, you end up in this huge case of Fender Lockin because there's no kind of standardized tag management layer just like. with that analytics, you know, there's been a lot of movement to try and make a digital. data layer that's consistent. That's W 3 compliant and all of that. But still the actual runtimes are very, very separate and for analytics layers you end up having to I mean how do they grab your data and they have to parse the Dom sometimes they have to hope it's there. What if there's a slow a. P. I call what if you're lazy loading stuff? How do you even handle that inside of a place where there's no hooks triggers or life cycles for analytics data layers to know that this is not ready yet so. a really cool thing where I can see this going would be the analytics just like how AP test you could have analytics repo or it's in Github and the tag manager is more in charging just orchestrating telling pretty much telling module federation. Here's the things that you need to do but the actual implementation is still under the engineer's control we would be able to just import you know some some reporting mechanism or some Telemetry system just like you would with a normal required statement and you could require this code and use exports that come from analytics layers and stuff like that specifically. for that team and as they need to make modifications or adjustments they're just Evergreen right to you. So there's very little need for this kind of cross collaboration communication. Everybody gets a really good turnaround time and overall everybody has a little bit more refined control over how the application boots itself and runs. It's not just a case of throw all the scripts in there up front and let it go. We actually could have more refined control and you could really treat these effectively separate organizational structures and systems as we know one big monolithic code base that just works in an extremely dynamic manner and is evergreen at runtime That's awesome. So you and I both work for big companies. have you seen any interest outside of in kind of a smaller team context or an open source application context

## OSS Integrations

* Yeah, I've seen a couple open source projects take some interest in this. I know single SPA. They use system JS and system JS has been a pretty good solve. I think probably one of the better solves to microfront and challenges in general, but it does have its limits in terms of just what you have to do to make it run quite as smoothly as It's not a drop in replacement. You you have to use that whole syntax and the. bundler is really kind of compatible with it where in mo The nice thing is it's all just still using the same ES6 workflow. You use a dynamic import and all of this. Sure, there's some magic happening under the hood from web pack to create these federated systems. But if you ever wanted to move away from a system like this, you just have to make sure that the file exists somewhere, or make it a node module, and it just keeps working, and you turn off the plug-in. So kind of moving back and forth between them is pretty easy. And so through a lot of back and forth with the single SPA team, we've looked at the work that they've done, and they've done a really good job at the orchestration aspect of this and dealing with how you mount and unmount separate apps. And how do you actually root between microfront ends of different technology and wouldn't. I look at, you know, this web pack plugin and the work that we've done to the webpack 5 core. the the overall motivation is a little bit different. Montrol Federation is really built for people to build things like single SPA off of. It's not a silver bullet, but it's a new way to design applications that previously we couldn't have these discussions about. Like arguing about, Oh well, you know, import maps over over easing the the module graph so that you can share vendor code at runtime or feature code at runtime. Those aren't arguments that have been possibly found even conversations that we could engage in open source space. So I know that. seagull s. P. A. They updated their documentation now for web pack. They've kind of recommended that if you use webpack 5 this is the way to go if you want something that's more bundler independent than system J. S. Is still a very good contender but the webpack aspect does offer a little bit more performance optimization just because we can load, you know, fragments of a runtime. We don't need a bootstrap and load the entire app. We don't have to manually really manage vendors or stuff like that. It will. download as little code as possible and recycle as much as available. So that's 1 of the nice setup open source projects that have taken interest in this and I know that there's some other things going on in open source space around the tooling aspects of this, but I have not really followed up a ton with open source authors and I think that the technology might not be as emerged yet for open source authors to really start digging into it. But I think that there's gonna be a very big market for tooling. and additional things that could really be built off of what's essentially a new type of front end paradigm or Java paradigm that we have the ability. to at runtime just load a piece of another compiled application with providing little to no context both on the server and in the plan is so much of what we've done has been kind of modeled around. Well, that's not possible to do straight up and you know Monterey foes, they became a big thing. And why did they become a big thing? Well, beyond the front end aspect, Mona Rifles have been a pretty good strategy in general to keeping things together. But what we're seeing is mono repos are kind of the only thing holding these things together. It's kind of flipped from its great way to organize code to world about other solution is there if you if you want it all together. This is the only like realistic way to share code share dependencies and have something that's somewhat optimized but that comes at the cost of a huge build and still if something goes wrong in there somebody fails a test somewhere else your entire mono repose down S you're still stuck in this monolithic area where there's just no redundancy and your bottleneck by you know 1 master branch and only one way to deploy. Yeah it takes takes mono repose down to just basically doing kind of version management as opposed to the sharing management as well. Hey this has been great and I definitely want to do this again and you know we got to catch up for a beer in Seattle when this is all over. Oh yeah definitely definitely have to all right. Thank you so much. This has been great alright check you later. Fantastic have a good day. You too Well, that was a lot of fun. And having Zach on is great. If you have any questions or comments, be sure to put them down in the comments below. We'll feel those as fast as we can And if you like this video, just hit that like button. If you are into these videos in general on this kind of content, be sure to hit that subscribe. That's going to help me out and get access to more content like this. So and of course, hit that bell button if you want to be notified anytime a new video is up. In the meantime, be happy, healthy, be safe. And at some point you're going to be able to have a beer with our friends, right? Bye.
