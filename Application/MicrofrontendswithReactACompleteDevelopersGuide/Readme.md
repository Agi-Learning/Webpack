# Microfrontends with React: A Complete Developer's Guide

## What is a Microfrontend

* Let's start to dive into the technical side of microfront. The first thing we're going to cover is exactly what a micro front end is. Obviously, a really important part of understanding what these things are all about and how to use them. So to really understand microfront ends, I first want to imagine that we are building some kind of ecommerce application like the 1 you see right here. So maybe our ecommerce application has two separate pages to it, a page to list out all the different products we have for sale. And then another page to show a shopping cart. Essentially all the items in the user intends to purchase. So in our application, we have these two separate pages. Let's imagine that we are building an application like this using a classic approach, where we have one single, single page application. We might build this using react or view or angular. And inside this project, we might have a lot of code around implementing some kind of product listing page and a lot of code to implement something around a shopping cart page. Because all the code for our entire application is in one single code base. You might refer to this as a monolithic, single page application. If. we wanted to turn this into a micro front end application, then we could take a look at our original knock ups and then try to identify each distinct and major feature inside of our app, go inside of our application. Here we really have two major distinct features. We've got the product listing page and the shopping cart page. After identifying each of these major features, we can then split each of them into their own separate code base. So we might have all the code for our product listing inside of one single page application using reactor. view angular or whatever else, or we might have all the code for our shopping cart inside of a totally separate application. Now, as soon as we start to split up these two different code bases, we start to run into a lot of interesting questions very quickly. For example, if a user clicks on this add to card button right here, we clearly have some kind of need to add this product to this cart listing page over here. Well, inside of a microfront end approach kind of application as much as possible, we try to prevent direct communication between these two distinct projects. Instead, to accomplish something like, say, adding a product to a cart, we would instead have our product listing application. maybe make some kind of request to an api that manages all the data inside the user's shopping cart. And then whenever a user loads up these shopping cart application to see their products that they've added to their cart, the shopping cart app would make a request that same api and get a listing of all the products that is in their cart. You'll notice that we do not have any kind of direct communication between these two smaller applications. Now, why would we use microfront X? What benefit do we get to splitting these things up into separate apps? Well, there's 1GIGANTIC very large benefit that we get, and that is that each of these applications can now be a thought of as separate, independent apps. There's no direct communication between them. There's no direct dependency between them. That means we could assign the development of product listing to, say, engineering team number one, who could just assign the development of this shopping cart app to a totally separate engineering team. These can be. two different engineering teams inside of our company and they could decide to make radically different technical decisions for implementing each of these projects. So for example, engineering team #1 could decide to build this project using react and maybe engineering team #2 could decide to implement this using angular or something else. Now of course, we probably want to limit the number of frameworks being used at our company, but the point here is that each engineering team can build their application with their own preferred development style whatever. works best for them. OK, so let's summarize what we've covered inside this video.
* It's a microfront ends are where we take a monolithic application and we divide it into multiple smaller applications. Each of these smaller applications are responsible for one distinct major feature of our product as much as possible. We try to prevent these different micro applications from communicating with each other directly We make use of microfront ends because it allows multiple different engineering teams to work on the same overall application, but in total isolation. O if engineering team a or number one, make some kind of breaking change to their A It's not going to necessarily break some other part of our application. In addition, when we start to divide our application out into microfront ends, it makes each of these smaller parts a lot easier to understand and make changes to without accidentally breaking some other part of our app as well. Ok, so good intro. Let's take a pause right here and go a little bit deeper in the next video.

## Application Overview

* Let's take a look at the first application we're going to build to get a better idea of how microfriends work Here's a little mock up. We're gonna make a very simple, very straightforward application that's going to use just about no frameworks inside of it. We're gonna make a kind of ecommerce store on this page. We're gonna list out a section where we have some different roducts for sale. And then underneath it will have another section where you list out the number of items that a user has in a cart. One thing you wanna make sure is clear right away is that we're working with 100% fake generated data here. We're not gonna make use of any API or anything like that. In addition, we're not gonna have any kind of interaction. So there's no actual adding items to a cart or anything like that We're really just trying to get some plain text to appear on the screen. And when I look at this application, I really see two distinct features. First off, we've got a listing of different products are available for sale And we also have a display of the cart. It's going to list out the number of items that a user has in the cart. And remember that number right there. So when it says one item, that's really just a randomly generated number, then we're going to stick inside there. So when we notice right away that we've got two distinct features, we might decide if we were making some kind of monolithic style application to do something like this. We might have some kind of a component that displays a product list component and a cart component. So again, this is what we would do if we were making a classic or traditional monolithic style app. But how would we approach this if we were making use of microfront ends? Well, we might decide to take each major feature of our product and put it into a different microfront and application So we could have microfront end number one that contains all the code related to our product listing feature. So essentially all the code needed to get this list of products to appear on the screen. We might also create a 2nd microfront end app that contains all the code needed to get this cart to be displayed on the screen. You'll notice right away that if we only have these two microfront ends, we might have a little bit of a challenge in actually getting these things to be displayed on the screen. In other words, how do we know that the microfunding number one needs to be displayed up here at the top and microfund end #2 needs to be displayed down here at the bottom to coordinate where to show each of these different microfront ends on the screen and when to show each of them. We very frequently end up creating a 3rd microfront end app that we usually refer to as the container The container is what decides when and where to show all the different microfront ends that we have So to build up this little fake ecommerce store, we're going to end up making 3 small projects. We're going to make this container A. We're going to make microfronted number one to show a listing of Roducts and microfunded number two to show the cart. We're going to decide when and where to show each of these microphone ends by adding in a little bit of logic to this container application. So let's get started on putting this all together in the next video.

## Understanding Build-Time Integration

* In the last video I mentioned that this container is going to decide when and where to show each microfront end. So that really implies that the container needs to get access to the source code of the product list and the cart at some point in time. So in this video, we're going to focus on the different ways of implementing that. We're going to focus on the different ways of making sure the container gets access to products list and cart. This entire process is referred to as integration. So whenever you hear the term integration, you need to think about how we're going to kind of assemble together or orchestrate our different microfront ends

### Integration

* Now, before we talk about any different method of integration, I want you to know that there are many different solutions, or many different ways, of putting integration together. But out of all these different possible solutions, none of them is perfect. They all have their upsides and their downsides. So deciding on when to use is really going to come down to what your requirements are for your application. Now, in general, there are three different categories of integration We have built time integration, which is also known as compile time. We have runtime, which is also known as client side and server. We're not going to focus too much on server because it requires a ton of back end code that we're not really going to get into inside this course. So we're going to focus a lot more on build time and runtime integration. Whenever we hear about build time integration, we are saying that we are going to make sure that our container gets access to the product's list source code before the container is loaded in the browser. With runtime integration, we are saying that the container is going to get access to the products list, and the carp source code after the container is loaded in the browser. So a very small distinction there, but it turns out that that distinction is rather important. So let's take a look first at an example of build time integration.

#### Build-Time Integration

* So this is one way of implementing build time integration. It is definitely not the only way. There are other methods of implementing real time integration, but this is a pretty straightforward way of understanding it. So with a built on integration approach, we might have one team that is in charge of developing the products list application. At some point in time, they're going to finish up their project, and they're going to say, ok, time to deploy the same At that point in time, the products list team would publish products list as an npm package. So they would take all the source code for it and publish it off to New Mexico and make it available as a package that could be installed into another project. Then the team in charge of container would install products list as a dependency using that same kind of npm install command that you're robably already familiar with The container team would then build up their application. And the result of that would be a bundle that has all the source code for container and all the source code for Roducts list. So that bundle right there implies that we have one javascript file, or possibly multiple, that has all the source code for products list and container put together. Now, there's some definite upsides and downsides to this approach. The first big pro is that it's really easy to set up this flow, and it's relatively easy to understand as well. You've robably already implemented a flow very much like this, without even really realizing it. If you've ever installed some kind of 3rd party component into one of your applications. So if you install a 3rd party component, you have taken use, or you've made use of some package that's been published by another team of Engineers. And you made use of it inside of your project The downside to this approach is that anytime the products list application needs to be redeployed, we would have to redeploy the container as well. The other big downside here is that, because the container has full and direct access to all the products list source code, it might be a little bit tempting to somehow tightly couple those two projects together, which is something that we don't really want to do in a microfront end architecture Okay. So that's an example of a build time integration. Let's take a pause right here, and then take a look at runtime integration as well in the next video.

#### Runtime integration

* Let's now take a look at what a runtime integration would look like. So here's an example of one possible way of imlementing a runtime integration. Once again, we might have an engineering team that develops the products list alication. They would eventually decide that it's time to deploy their application. And at that point, rather than deploying their project to say NPM or something like that, they would bundle up their project and deploy it to some static url, something like, say, my app.com slash products list .js. So this. javascript file right here has all the source code for the products list application. So then whenever a user navigates to, say, Myappcom, we've been load up the container A. And at that point in time, the container app would then fetch that productslist .javascript file for js file and execute it. So notice that in this approach, the container only gets access to the source code of products list after the container has been loaded into the browser. Now this approach has upsides and downsides as well. So the runtime integration, the big upside is that we can independently deploy the product list alication at any time without having to redeploy the container. That's definitely a big upside. Another big upside is that we can easily have different live versions of the products list application. So we might be doing some kind of AB testing where we have two versions of the products list. And it can be up to the container to decide which of those two versions to use. The downside to this approach is that the tooling and the setup board is way, way more complicated. And there's really a lot more going on here that you have to understand as an engineer. Having said all this, and having kind of compared a runtime integration versus a build time integration, in this course, you and I are going to be focused 100 a on a runtime integration. And we're going to implement it using webpack module federation. The reason that we're covering this inside this course is that it is definitely the hardest thing to set up and to understand. And so in my opinion, it makes it way more sensible to cover this inside of a course where I can essentially walk you through everything use by piece and help you really understand what is going on now. Let me be clear, you might be saying, hey, Steven, I don't want to do the hardest thing here as I'm just getting started. Don't worry. When I say hardest to set up, I just kind of mean relatively. It's still, it's not going to be ridiculously hard. I just want you to be aware that we're going to be doing this approach because it just makes a little bit more sense to cover it in a course where you can have a lot of kind of guided instruction as you go through. The real reason that we're using this approach is that it's definitely the most flexible and performant solution for doing integration right now. One of the big downsides, however, is that we're going to have to spend a lot of time around web pack and really understanding what webpack is doing for us and how it works. If you don't know anything about Webac right now, that's totally fine. I'll give you a really good overview in the coming videos. Okay, so now we've got a better idea of what's going on. Let's start to tackle our application in the next video.

## Project Structure

* Let's take a look at how we're going to implement our ecommerce project using a runtime integration. To get started, we're going to create a separate folder for each of our different microfront ends So one forward container, one for card and one for products. Each of these different folders Internet that project and get it running in both isolation, in other words, by itself and as a part of the overall application. Everyone of these 3 different folders for this project is going to have the same different files inside of it. So we'll have an index dot js file with some implementation. We'll have an html file, a package dot json file, to list out all this sub projects dependencies. And then finally, a webpack config file as well. Each of our different sub projects are going to be built without using any javascript framework. So for this first go, no react, no angular, no view, just plain javascript. And again, we want to make sure that we can run each of these in isolation and through the container A as well. We're going to first focus on the implementation of the products microfront end. So just products by itself. We're not going to worry about the container or anything like that. To get started, let's open up our terminal. We'll create a couple of different files and folders. All right, I'm going to open up my terminal.

### Setup

* And once I'm in my tremell, I'm going to make a new workspace directory that's going to eventually hold all of our different sub projects. I'm going to call mine ecom short for ecommerce. I'll then change into that directory. And inside there, I'm going to make my first sub project. I'm going to create a folder called products and then change into that as well. Now Inside of products, we're going to first begin by generating a package Jason file. We'll do that with an NPM init -Y Once we've created that file, we'll then install a couple of different dependencies. Now as we install these dependencies, I really must ask you to use the exact same versions I'm going to use. This entire field of microfund ends is very fast moving and I could just about guarantee that if you don't use the same version as I, your code will probably break at some point in time. So we're going to do an em install. And we will install Webac at 5.4. We will get webpack cli at 4.2 Wet pack dev server. At 3.11 .0. And then just two more Baker at 5.1 .0. And finally html web pack plugin at. 4.5 .0. I apologize for all the typing. But like I said, really important for us to just make sure that we're using the exact same versions of all these different modules. So I'm going to start that installation process, and we'll come back together in the next video and move on from there

### Generating Products

* All my dependencies are installed, so I'm not going to open up my code editor inside of this product's directory, and we're going to start to put together some basic implementation for the product list. To get started, I'm going to create a src directory inside of here And then inside of that folder, i'll make a new file called Indexjs So eventually inside this file, we're going to want to generate a list of products and show them on the screen to our users. But right now,list of product. we're going to want to generate a list of products and show them on the screen to our usersAnd console login instead. I'm not going to worry about trying to render them onto any screen or anything like that. To generate a fake list of products, I'm going to make use of the Baker module that we installed just a moment ago. The Baker Library is used to generate fake data. That's all it does. Nothing else. So we can use Baker to generate some fake product names and stuff like that. To make these big product names, I'm going to create a new variable with a let keyword that I'll call products, and going to assign that an empty string I'm going to create a for loop. And iterate from zero to I less than 3. Inside of here will generate a product name using the Baker Library. So I'll do a faker dot commerce dot product name Double check your spelling on commerce right there. Just make sure you've got the correct spelling. That's going to give us a fake product name, which will work for the purposes of our application I'm not going to join that into this product string. I'm going to join it in essentially as a little bit of html. Again, right now we're just going to console log this out right now, but eventually we will render it onto the screen. I'm going to do a products plus equals and then a set of Bactics. And inside of a division, I'm going to print out. Name like cell. And then finally, at the bottom, after the 4 loop, i'll do a console log Of products Ok, so just a very simple, very basic implementation for right now. So if we wanted to run this as it stands right now, we would get a lot of errors if we tried to execute this code inside the browser. And that's because a lot of browsers do not have support for import sevents right now. So rather than trying to execute this code directly, we're going to instead use that web pack dependency to install just a moment to go. So remember, I mentioned that in this course, we need to have some reasonable knowledge of web pack and how it works. So let's take a pause right here when come back to next video. We're going to use webpack to transform our processes file. And in the process, we'll get a good review or overview, depending on how familiar you are with it around webpack

### Some Background on Webpack

* Let's set up webpack so it processes Excellent processes this index js file. Like I said, We're going to get a better idea of how webpack works in general. So to get started inside of my root project directory, I'm gonna make a new file called Make a new file called Webpack config.js Than inside here. I'm going to do a module dot exports of an empty object. And the only thing we're going to write inside of here is mode develop. Like so. Then after that, we're going to open our package .Json file. Now I'm going to find the script section inside of here. I'm going to replace the test script with start And we're going to have the start script just run wet pack for right now. I'm gonna make sure I save both these files I'll then go backward my terminal, and I'm going to run that start script. So back at my terminal inside the products directory, i'll do an npm run start. We're then going to very quickly see a ton of output scroll across the screen. It looks like something was built successfully. Okay, that's good. Let's really investigate what was created and what just happened behind the scenes with webpack. So back inside my editor, I can find a new directory inside of here called Dist, Shortcord distribution. Inside there is a main dot js file. I'm going to open that file U. Now, right away, you're going to see a tremendous amount of content inside of here. And the vast majority of it is probably going to be very hard to read and understand. That's totally okay. I just want to point out a couple of different qualities about this file. But first, let's take a look at a diagram very quickly. OK
* So we just wrote out an index js file. Inside that file, we wrote out an import statement to get access to the Baker module. The Baker module is not just one single file. Instead, faker is composed of many different files internally. When we wrote out that import statement, we were essentially saying that we want to appeal a collection of different files from that Baker module and make use of those different files inside of our index dot js file. So we can really picture the code that we just wrote out as being like the left hand side of this diagram, right here We created an index dot js file, and we imported into it a couple of different dependencies. We can see all the different files that constitute the Baker module. If we take a look back at our terminal You'll notice that all these different lines are referring to different files within the faker module So I've got something around Baker, some more Baker. These are all files around Baker. So we can see very easily. There's a lot of different files that are being included, just we can make use of Baker. Now, of course, when we start to load up all of our code inside the browser, in general, as real thumb, we do not want to load U many different files. Instead, it usually makes a little bit more sense to load U as few files as possible. Now there's a lot of different variations on that rule, and it's not a hard and fast rule, but in general, we don't want to try to load up hundreds of different files into the browser. And that's where webpack comes into play. So the goal of Webpack is to take many different javascript files, which we have right now, even with one single dependency And combined the mall down to one single output file, which in our case was named by default main dot js. That's the file we just saw inside of that disk directory. That main .js file is the output of Webpath. You will frequently see that file also named as bundle as well. So that one single file contains not only the code from our index js file, but also all those different files from Faker as well If we go back over to our editor and take a look at the main dot js file, we can scroll through here. And even though a lot of this code looks really confusing, you can see that there are references to Baker Index .js. So that's the index .js file inside the Baker module We can see some stuff around addresses and commerce and company. These are all different files, all of the different code inside these files have been extracted and thrown into these different eval statements. So you'll notice this evil function. If you scroll all the way to the right hand side, it's a really, really long line of code. This one line contains all the code out of that 1 file inside the Baker module. So we can see very easily that web pack is taken all the code out of these different files essentially place them into this one main dot js file We can find the code out of our index dot js file. If we go down to the very bottom of this file and then scroll back up just a little bit And you'll see right here a comment for src index js. So that is our file. So all the code out of our index .js file is contained inside this eval line right here. You will notice that there's a lot of extra code inside of here as well, just due to how web pack processes are code. If you scroll over to the right barn up, you'll eventually see some stuff around creating that product string. And then our for loop. The body of the for loop. And then eventually the console log of products right there. So at this point in time, all I really want you to understand around Webpack is that we throw in some collection of files. It somehow combines all those files together into one single file, and we get this output named either bundle or main, or any other other couple of names. We can really name that file anything we want, but usually by convention it's called either main js or bundle js. Okay, so now you've seen a little bit around web pack. Let's start to expand a little bit more in the next video.

### Touch More on Webpack

* We've now got our name As file created, but just creating this file doesn't really do us a whole lot. We now want to somehow take this file and execute it inside the browser and make sure that eventually the code inside viewer generates some html that gets displayed on the screen. So we need to load up main dot js into the browser. To do so, we're going to first set up a little module called Webpackdev Server. Webpackdev server is going to take the output from our webpack process and make it available in the browser To set up webpackdev server, we already installed it just a moment ago. All we have to do is make a change to our webpack config file. So back inside of our editor, I'm going to find the Webackconfigjs file. I'm going to add a new section inside of here of dev server. Make sure that server has a capital S. Then I'll put in a port of 8081. That's really important that you use a port of 8081.
* Later on, this port number is going to become very critical. And we need to make sure that we've got absolutely identical port numbers, otherwise you're going to have to figure out some configuration steps on your own. I'm gonna save that file, and then to make sure that I run webpack with dev server enabled, I will also go into my package dot Json file. I'm going to find the start script again, and I'll update the command to webpack serve like so I'll then go back over my terminal and let's run npm run start once again After another little pause, we'll see a message right there, very briefly, that says that our project is running at localhost colon 8081. Now we can access the main dot js file that was created by opening up our web browser. And navigating to local host 8081 slash main dot JS. And there is the contents of our main.js file. You'll notice that we are seeing the contents of the file, which is not really useful to us. We don't want to see the contents. We want to run this file to run the file. We have to create an html document and then reference this main dot js file using a script tag. So let's go through that process as well right away.
* Back inside my editor.I'm going to create a new directory that I will call public. Then inside that public folder, I'm going to make a new file called index.html At the very top, I'll put in a doctype I'll put in an html tag Ahead. A body. And that's all I'm going to put in for right now. You'll notice that we don't have any scrit tag inside of here at all. Well, it turns out that when we are making use of Webac, we are not going to try to manually reference that main dot js file. Instead, we're going to have webpack figure out how to add the script inside of here for us. Let me show you a diagram to help you understand why we're going to do that. Ok so event Actually, we want to load up an html document inside our browser that's going to have a script tag that tries to load up that main dot js file. We should see some kind of scrit tag that says something like source main dot js, or something like that. We could definitely add that in manually. But as you're going to see very quickly, and I can actually kind of modify our index js file to do this very easily, we might eventually have files coming out of Webpack that do not have predictable names. Right now, our file that comes out once it's been joined together is always going to be called main dot js. But it's very. easy to accidentally make some changes to your project, and you're going to eventually want to make these changes And that's going to have web pack spin out some file names that have dramatically different names. That are absolutely unpredictable. So it might have some kind of identifier like this, right at the start of the file name. And these different identifiers are going to be really hard for you to guess. O, we can't really just have a static script inside of our html document, because it would be really challenging for us to guess what those identifiers are always going to be. So instead, we're going to make use of a little plug in called Webpackhtml Plugin. Actually, I think it's called html webpack plugin. This plugin is going to take a look at the different files that are coming out of Webpack. It's going to take a look at those file names and then automatically update that html document we just put together to add in some script tags that specifically reference these very specially named files. So this plugin is essentially going to create for us and add into the html document the rescript tags with the name of 1 K4J43 bundle. and 4 6J3JI.bundle. And the last one right there as well. So this plugin will make sure that we always load up the correct output files that are coming out of webpack. So let's set up that plugin and tell it to modify that html document we just put together To do so, we'll go back over to our web pack config file at the very top. We will import that plugin with html weback lugin And then at the bottom of this object, I'm going to put in a plugin's array inside there. I'll add in new html web ack lugin We're going to pass it in object, give it a template property, and tell it to use the html file inside of publicindex dot html. So this plugin is going to take a look at whatever files are coming out of our web pack process. It's going to find those file names and then add the appropriate script tags automatically behind the scenes to this html snippet right here. OK, so let's save thisWe'll go back over to our terminal, and we're going to restart webpack. We're going to do a control c And then another mpm run start. And now, if we go back over to our browser And go to local host 8081 without any file names or anything like that, and open up our console. We will see our console log from our code O. It looks like the contents of our index .js file is now correctly being executed. We can also make changes to that file at will. So how about back inside of our index dot js file? Let's now do everything from zero up to 5. We're going to do an I lesson 5 right there. That should automatically be updated by webpack So back in our terminal looks like webpacks saw the update we just made to that file. And if we now go back over to our browser, it looks like the console log has automatically been updated as well. And we now see five products being generated Ok, so that is the basics of Webac. We've now gone through the process of having webpack in cat meat together, not really concatenate, but combine together a bunch of different files, roduce 1 output file. And we are now loading that file up inside of our browser. Now, if all this stuff is just total review for you, I apologize for the review on Webpack, but it's really important for you to understand these basics. Because as we go through this idea of module federation inside a wet pack, it becomes super critical for you to understand what is going on behind the scenes with webpac so Just take a pause right here and continue in just a moment.

### Finishing the Product List

* To finish off our products microfront end, we need to make sure that our list of products we've now generated somehow gets displayed on the screen to the user. To do so, I'm going to open up my index HTML file inside of that body element. I'm going to add in a new division with an ID of dev dash products. And closet div off. I'm going to save that html file. I'll then go back over to my index dot js file. I'm going to delete the console log of products. And I'm going to replace it with a query selector For that element we just created, and to show our list of products on the screen, we're going to set that element's inner html property to Roducts. Do notice that inner html, the html right there has all capitals. So let's now save this file and go back over the browser and just make sure that our list of products is being displayed Yeah, there we go Well, believe it or not, that is kind of it for our products microfront ends. We are now generating a list of products and showing them to the user. But that's not really the end of what we need to do inside this project. Right now, we have developed a stand alone application. This thing works by itself, but there's really nothing inside of it to ensure that we can somehow integrate this with our container application. So let's have another quick pause right now. When we come back, we'll figure out how we can somehow plan a random integrating products with the container app once we build it.

### Scafolding the container

*The products microfunded is now in a pretty good state, so now we're going to start to work on our container and then figure out how to integrate these two microfront ends together. So let's start working on container. I'm going to 1st begin by going back over to my terminal. I'm going to open up a 2nd terminal window You'll notice that it is automatically open for me inside the products directory. I'm going to go up one directory. So I'm back inside of our ecommerce folder. So I should see our products roject right there. So once I'm inside of the econ directory, i'll then make a new folder to house everything related to our container. I'll change into that container directory. And then, once again, I'm going to create a package dot Json file with New Mexico init Y Once I've generated that file, we're then going to again install a couple of different dependencies. These are going to be the exact same dependencies that we added in to our products project with one exception. We're not going to add in the Baker module to our container because the container just doesn't need it for any reason. So we will do an npm install. We're going to do html web pack plugin at 4.5 .0. We'll get node mon we don't need to specify a version on that. We'll get web pack at 532 Web packed cli at 410. And then finally, webpack dev server at 311 0 I'm gonna run that. And while that's going, I'm gonna flip back over to my code editorInside my code editor, I can currently only see the product's directory. I'm going to reopen my code editor so I can work on both the products and the container projects at the same time. To do so, i'll go to file and then open I'm then going to select my ecom directory. And open that. Now, if you're in windows, the process will be just slightly different. But ultimately, all we want to do is open up the ecom project inside of our editor O. We should see both our container and our roducts folders.

* Ok so now we're going to do a little bit more setup on our container. The setup inside of here is going to revolve around the exact same files we had created for our products. But some of the files are going to have some different configuration and code inside them. At the end of the day, though, we're going to have to be pretty much the same files in index .js and html file and a web pack config So I'll first begin by creating that index html file. I'm going to create a new directory called public. And then an index.html inside there I'll place my duck tight. An html tag There's my head. My body And we're going to leave it just like that for right now. So one thing I want to point out here is that inside of our container html document, we've got an emty body. And inside of our products, html file, we've got a div where we can render our actual products project. So that list of projects are going to be inserted into that div right there. So it's going to point out really quickly that these two html files are just slightly different. Next up inside of our container, we're going to make another folder of src Inside there, I'll make a new file called index .js. And right now I'll do a very simple console log, and I'll just say, container I'll then save that file and close it. And then finally, we'll make one more file, the Webpackconfigjs file So for right now, this file is going to look kind of similar to what we just did over inside of products. But we're going to very quickly make some big changes to it. O inside of here, we still want to have that html webpack plugin And I'm going to require that from. Html web pack plugin will then do another module exports. We'll set our mode to development. We'll set our dev server. And this time around, for our port, we're going to say 8080O. At this point in time, remember, our roducts roject is on ort 8081. And our container is going to be on 88. And then finally, we'll set up our plugin's array. We'll have a new Html webpack plugin. We'll set the template To be publicindex html Ok, just one last piece of setup inside of our package dot Json file. We'll make sure that we add in our start script. O, I'm going to replace inside of ackage .Json inside the container directory, test, hit start. And whenever we run that, we're going to actually execute our. Wet pack serve like so. Ok, so we've now got products, and we've got container. These are two separate projects. There's no link between them. There's no tie, there's no integration at all. Just make sure the container is working by itself. Let's go over to our command line, make sure we can launch container, and then just try to visit it inside of our browser. So back at my terminal, it looks like my MPM install is all complete. I'll make sure I'm inside my container directory, and I'll do an npm start or an npm run start. Either one is totally fine. OK, so looks like everything has started up I don't see any errors. I might see a warning or two fully fine. Now, to make sure that our container is working correctly, I will open up my browser once again And then I will navigate manually to localhost 8080. And I should see inside my console something that says container like so. Ok, so we've now got two rojects created, and now we need to think about how we're going to integrate them together. So as you can guess, that's going to be a big topic for our next video. So quick pause right here, and we'll dive right in.
