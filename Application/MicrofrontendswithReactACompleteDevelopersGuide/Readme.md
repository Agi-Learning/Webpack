# Microfrontends with React: A Complete Developer's Guide

## What is a Microfrontend

* Let's start to dive into the technical side of microfront. The first thing we're going to cover is exactly what a micro front end is. Obviously, a really important part of understanding what these things are all about and how to use them. So to really understand microfront ends, I first want to imagine that we are building some kind of ecommerce application like the 1 you see right here. So maybe our ecommerce application has two separate pages to it, a page to list out all the different products we have for sale. And then another page to show a shopping cart. Essentially all the items in the user intends to purchase. So in our application, we have these two separate pages. Let's imagine that we are building an application like this using a classic approach, where we have one single, single page application. We might build this using react or view or angular. And inside this project, we might have a lot of code around implementing some kind of product listing page and a lot of code to implement something around a shopping cart page. Because all the code for our entire application is in one single code base. You might refer to this as a monolithic, single page application. If. we wanted to turn this into a micro front end application, then we could take a look at our original knock ups and then try to identify each distinct and major feature inside of our app, go inside of our application. Here we really have two major distinct features. We've got the product listing page and the shopping cart page. After identifying each of these major features, we can then split each of them into their own separate code base. So we might have all the code for our product listing inside of one single page application using reactor. view angular or whatever else, or we might have all the code for our shopping cart inside of a totally separate application. Now, as soon as we start to split up these two different code bases, we start to run into a lot of interesting questions very quickly. For example, if a user clicks on this add to card button right here, we clearly have some kind of need to add this product to this cart listing page over here. Well, inside of a microfront end approach kind of application as much as possible, we try to prevent direct communication between these two distinct projects. Instead, to accomplish something like, say, adding a product to a cart, we would instead have our product listing application. maybe make some kind of request to an api that manages all the data inside the user's shopping cart. And then whenever a user loads up these shopping cart application to see their products that they've added to their cart, the shopping cart app would make a request that same api and get a listing of all the products that is in their cart. You'll notice that we do not have any kind of direct communication between these two smaller applications. Now, why would we use microfront X? What benefit do we get to splitting these things up into separate apps? Well, there's 1GIGANTIC very large benefit that we get, and that is that each of these applications can now be a thought of as separate, independent apps. There's no direct communication between them. There's no direct dependency between them. That means we could assign the development of product listing to, say, engineering team number one, who could just assign the development of this shopping cart app to a totally separate engineering team. These can be. two different engineering teams inside of our company and they could decide to make radically different technical decisions for implementing each of these projects. So for example, engineering team #1 could decide to build this project using react and maybe engineering team #2 could decide to implement this using angular or something else. Now of course, we probably want to limit the number of frameworks being used at our company, but the point here is that each engineering team can build their application with their own preferred development style whatever. works best for them. OK, so let's summarize what we've covered inside this video.
* It's a microfront ends are where we take a monolithic application and we divide it into multiple smaller applications. Each of these smaller applications are responsible for one distinct major feature of our product as much as possible. We try to prevent these different micro applications from communicating with each other directly We make use of microfront ends because it allows multiple different engineering teams to work on the same overall application, but in total isolation. O if engineering team a or number one, make some kind of breaking change to their A It's not going to necessarily break some other part of our application. In addition, when we start to divide our application out into microfront ends, it makes each of these smaller parts a lot easier to understand and make changes to without accidentally breaking some other part of our app as well. Ok, so good intro. Let's take a pause right here and go a little bit deeper in the next video.

## Application Overview

* Let's take a look at the first application we're going to build to get a better idea of how microfriends work Here's a little mock up. We're gonna make a very simple, very straightforward application that's going to use just about no frameworks inside of it. We're gonna make a kind of ecommerce store on this page. We're gonna list out a section where we have some different roducts for sale. And then underneath it will have another section where you list out the number of items that a user has in a cart. One thing you wanna make sure is clear right away is that we're working with 100% fake generated data here. We're not gonna make use of any API or anything like that. In addition, we're not gonna have any kind of interaction. So there's no actual adding items to a cart or anything like that We're really just trying to get some plain text to appear on the screen. And when I look at this application, I really see two distinct features. First off, we've got a listing of different products are available for sale And we also have a display of the cart. It's going to list out the number of items that a user has in the cart. And remember that number right there. So when it says one item, that's really just a randomly generated number, then we're going to stick inside there. So when we notice right away that we've got two distinct features, we might decide if we were making some kind of monolithic style application to do something like this. We might have some kind of a component that displays a product list component and a cart component. So again, this is what we would do if we were making a classic or traditional monolithic style app. But how would we approach this if we were making use of microfront ends? Well, we might decide to take each major feature of our product and put it into a different microfront and application So we could have microfront end number one that contains all the code related to our product listing feature. So essentially all the code needed to get this list of products to appear on the screen. We might also create a 2nd microfront end app that contains all the code needed to get this cart to be displayed on the screen. You'll notice right away that if we only have these two microfront ends, we might have a little bit of a challenge in actually getting these things to be displayed on the screen. In other words, how do we know that the microfunding number one needs to be displayed up here at the top and microfund end #2 needs to be displayed down here at the bottom to coordinate where to show each of these different microfront ends on the screen and when to show each of them. We very frequently end up creating a 3rd microfront end app that we usually refer to as the container The container is what decides when and where to show all the different microfront ends that we have So to build up this little fake ecommerce store, we're going to end up making 3 small projects. We're going to make this container A. We're going to make microfronted number one to show a listing of Roducts and microfunded number two to show the cart. We're going to decide when and where to show each of these microphone ends by adding in a little bit of logic to this container application. So let's get started on putting this all together in the next video.

## Understanding Build-Time Integration

* In the last video I mentioned that this container is going to decide when and where to show each microfront end. So that really implies that the container needs to get access to the source code of the product list and the cart at some point in time. So in this video, we're going to focus on the different ways of implementing that. We're going to focus on the different ways of making sure the container gets access to products list and cart. This entire process is referred to as integration. So whenever you hear the term integration, you need to think about how we're going to kind of assemble together or orchestrate our different microfront ends

### Integration

* Now, before we talk about any different method of integration, I want you to know that there are many different solutions, or many different ways, of putting integration together. But out of all these different possible solutions, none of them is perfect. They all have their upsides and their downsides. So deciding on when to use is really going to come down to what your requirements are for your application. Now, in general, there are three different categories of integration We have built time integration, which is also known as compile time. We have runtime, which is also known as client side and server. We're not going to focus too much on server because it requires a ton of back end code that we're not really going to get into inside this course. So we're going to focus a lot more on build time and runtime integration. Whenever we hear about build time integration, we are saying that we are going to make sure that our container gets access to the product's list source code before the container is loaded in the browser. With runtime integration, we are saying that the container is going to get access to the products list, and the carp source code after the container is loaded in the browser. So a very small distinction there, but it turns out that that distinction is rather important. So let's take a look first at an example of build time integration.

#### Build-Time Integration

* So this is one way of implementing build time integration. It is definitely not the only way. There are other methods of implementing real time integration, but this is a pretty straightforward way of understanding it. So with a built on integration approach, we might have one team that is in charge of developing the products list application. At some point in time, they're going to finish up their project, and they're going to say, ok, time to deploy the same At that point in time, the products list team would publish products list as an npm package. So they would take all the source code for it and publish it off to New Mexico and make it available as a package that could be installed into another project. Then the team in charge of container would install products list as a dependency using that same kind of npm install command that you're robably already familiar with The container team would then build up their application. And the result of that would be a bundle that has all the source code for container and all the source code for Roducts list. So that bundle right there implies that we have one javascript file, or possibly multiple, that has all the source code for products list and container put together. Now, there's some definite upsides and downsides to this approach. The first big pro is that it's really easy to set up this flow, and it's relatively easy to understand as well. You've robably already implemented a flow very much like this, without even really realizing it. If you've ever installed some kind of 3rd party component into one of your applications. So if you install a 3rd party component, you have taken use, or you've made use of some package that's been published by another team of Engineers. And you made use of it inside of your project The downside to this approach is that anytime the products list application needs to be redeployed, we would have to redeploy the container as well. The other big downside here is that, because the container has full and direct access to all the products list source code, it might be a little bit tempting to somehow tightly couple those two projects together, which is something that we don't really want to do in a microfront end architecture Okay. So that's an example of a build time integration. Let's take a pause right here, and then take a look at runtime integration as well in the next video.

#### Runtime integration

* Let's now take a look at what a runtime integration would look like. So here's an example of one possible way of imlementing a runtime integration. Once again, we might have an engineering team that develops the products list alication. They would eventually decide that it's time to deploy their application. And at that point, rather than deploying their project to say NPM or something like that, they would bundle up their project and deploy it to some static url, something like, say, my app.com slash products list .js. So this. javascript file right here has all the source code for the products list application. So then whenever a user navigates to, say, Myappcom, we've been load up the container A. And at that point in time, the container app would then fetch that productslist .javascript file for js file and execute it. So notice that in this approach, the container only gets access to the source code of products list after the container has been loaded into the browser. Now this approach has upsides and downsides as well. So the runtime integration, the big upside is that we can independently deploy the product list alication at any time without having to redeploy the container. That's definitely a big upside. Another big upside is that we can easily have different live versions of the products list application. So we might be doing some kind of AB testing where we have two versions of the products list. And it can be up to the container to decide which of those two versions to use. The downside to this approach is that the tooling and the setup board is way, way more complicated. And there's really a lot more going on here that you have to understand as an engineer. Having said all this, and having kind of compared a runtime integration versus a build time integration, in this course, you and I are going to be focused 100 a on a runtime integration. And we're going to implement it using webpack module federation. The reason that we're covering this inside this course is that it is definitely the hardest thing to set up and to understand. And so in my opinion, it makes it way more sensible to cover this inside of a course where I can essentially walk you through everything use by piece and help you really understand what is going on now. Let me be clear, you might be saying, hey, Steven, I don't want to do the hardest thing here as I'm just getting started. Don't worry. When I say hardest to set up, I just kind of mean relatively. It's still, it's not going to be ridiculously hard. I just want you to be aware that we're going to be doing this approach because it just makes a little bit more sense to cover it in a course where you can have a lot of kind of guided instruction as you go through. The real reason that we're using this approach is that it's definitely the most flexible and performant solution for doing integration right now. One of the big downsides, however, is that we're going to have to spend a lot of time around web pack and really understanding what webpack is doing for us and how it works. If you don't know anything about Webac right now, that's totally fine. I'll give you a really good overview in the coming videos. Okay, so now we've got a better idea of what's going on. Let's start to tackle our application in the next video.

## Project Structure

* Let's take a look at how we're going to implement our ecommerce project using a runtime integration. To get started, we're going to create a separate folder for each of our different microfront ends So one forward container, one for card and one for products. Each of these different folders Internet that project and get it running in both isolation, in other words, by itself and as a part of the overall application. Everyone of these 3 different folders for this project is going to have the same different files inside of it. So we'll have an index dot js file with some implementation. We'll have an html file, a package dot json file, to list out all this sub projects dependencies. And then finally, a webpack config file as well. Each of our different sub projects are going to be built without using any javascript framework. So for this first go, no react, no angular, no view, just plain javascript. And again, we want to make sure that we can run each of these in isolation and through the container A as well. We're going to first focus on the implementation of the products microfront end. So just products by itself. We're not going to worry about the container or anything like that. To get started, let's open up our terminal. We'll create a couple of different files and folders. All right, I'm going to open up my terminal.

### Setup

* And once I'm in my tremell, I'm going to make a new workspace directory that's going to eventually hold all of our different sub projects. I'm going to call mine ecom short for ecommerce. I'll then change into that directory. And inside there, I'm going to make my first sub project. I'm going to create a folder called products and then change into that as well. Now Inside of products, we're going to first begin by generating a package Jason file. We'll do that with an NPM init -Y Once we've created that file, we'll then install a couple of different dependencies. Now as we install these dependencies, I really must ask you to use the exact same versions I'm going to use. This entire field of microfund ends is very fast moving and I could just about guarantee that if you don't use the same version as I, your code will probably break at some point in time. So we're going to do an em install. And we will install Webac at 5.4. We will get webpack cli at 4.2 Wet pack dev server. At 3.11 .0. And then just two more Baker at 5.1 .0. And finally html web pack plugin at. 4.5 .0. I apologize for all the typing. But like I said, really important for us to just make sure that we're using the exact same versions of all these different modules. So I'm going to start that installation process, and we'll come back together in the next video and move on from there

### Generating Products

* All my dependencies are installed, so I'm not going to open up my code editor inside of this product's directory, and we're going to start to put together some basic implementation for the product list. To get started, I'm going to create a src directory inside of here And then inside of that folder, i'll make a new file called Indexjs So eventually inside this file, we're going to want to generate a list of products and show them on the screen to our users. But right now,list of product. we're going to want to generate a list of products and show them on the screen to our usersAnd console login instead. I'm not going to worry about trying to render them onto any screen or anything like that. To generate a fake list of products, I'm going to make use of the Baker module that we installed just a moment ago. The Baker Library is used to generate fake data. That's all it does. Nothing else. So we can use Baker to generate some fake product names and stuff like that. To make these big product names, I'm going to create a new variable with a let keyword that I'll call products, and going to assign that an empty string I'm going to create a for loop. And iterate from zero to I less than 3. Inside of here will generate a product name using the Baker Library. So I'll do a faker dot commerce dot product name Double check your spelling on commerce right there. Just make sure you've got the correct spelling. That's going to give us a fake product name, which will work for the purposes of our application I'm not going to join that into this product string. I'm going to join it in essentially as a little bit of html. Again, right now we're just going to console log this out right now, but eventually we will render it onto the screen. I'm going to do a products plus equals and then a set of Bactics. And inside of a division, I'm going to print out. Name like cell. And then finally, at the bottom, after the 4 loop, i'll do a console log Of products Ok, so just a very simple, very basic implementation for right now. So if we wanted to run this as it stands right now, we would get a lot of errors if we tried to execute this code inside the browser. And that's because a lot of browsers do not have support for import sevents right now. So rather than trying to execute this code directly, we're going to instead use that web pack dependency to install just a moment to go. So remember, I mentioned that in this course, we need to have some reasonable knowledge of web pack and how it works. So let's take a pause right here when come back to next video. We're going to use webpack to transform our processes file. And in the process, we'll get a good review or overview, depending on how familiar you are with it around webpack

### Some Background on Webpack

* Let's set up webpack so it processes Excellent processes this index js file. Like I said, We're going to get a better idea of how webpack works in general. So to get started inside of my root project directory, I'm gonna make a new file called Make a new file called Webpack config.js Than inside here. I'm going to do a module dot exports of an empty object. And the only thing we're going to write inside of here is mode develop. Like so. Then after that, we're going to open our package .Json file. Now I'm going to find the script section inside of here. I'm going to replace the test script with start And we're going to have the start script just run wet pack for right now. I'm gonna make sure I save both these files I'll then go backward my terminal, and I'm going to run that start script. So back at my terminal inside the products directory, i'll do an npm run start. We're then going to very quickly see a ton of output scroll across the screen. It looks like something was built successfully. Okay, that's good. Let's really investigate what was created and what just happened behind the scenes with webpack. So back inside my editor, I can find a new directory inside of here called Dist, Shortcord distribution. Inside there is a main dot js file. I'm going to open that file U. Now, right away, you're going to see a tremendous amount of content inside of here. And the vast majority of it is probably going to be very hard to read and understand. That's totally okay. I just want to point out a couple of different qualities about this file. But first, let's take a look at a diagram very quickly. OK
* So we just wrote out an index js file. Inside that file, we wrote out an import statement to get access to the Baker module. The Baker module is not just one single file. Instead, faker is composed of many different files internally. When we wrote out that import statement, we were essentially saying that we want to appeal a collection of different files from that Baker module and make use of those different files inside of our index dot js file. So we can really picture the code that we just wrote out as being like the left hand side of this diagram, right here We created an index dot js file, and we imported into it a couple of different dependencies. We can see all the different files that constitute the Baker module. If we take a look back at our terminal You'll notice that all these different lines are referring to different files within the faker module So I've got something around Baker, some more Baker. These are all files around Baker. So we can see very easily. There's a lot of different files that are being included, just we can make use of Baker. Now, of course, when we start to load up all of our code inside the browser, in general, as real thumb, we do not want to load U many different files. Instead, it usually makes a little bit more sense to load U as few files as possible. Now there's a lot of different variations on that rule, and it's not a hard and fast rule, but in general, we don't want to try to load up hundreds of different files into the browser. And that's where webpack comes into play. So the goal of Webpack is to take many different javascript files, which we have right now, even with one single dependency And combined the mall down to one single output file, which in our case was named by default main dot js. That's the file we just saw inside of that disk directory. That main .js file is the output of Webpath. You will frequently see that file also named as bundle as well. So that one single file contains not only the code from our index js file, but also all those different files from Faker as well If we go back over to our editor and take a look at the main dot js file, we can scroll through here. And even though a lot of this code looks really confusing, you can see that there are references to Baker Index .js. So that's the index .js file inside the Baker module We can see some stuff around addresses and commerce and company. These are all different files, all of the different code inside these files have been extracted and thrown into these different eval statements. So you'll notice this evil function. If you scroll all the way to the right hand side, it's a really, really long line of code. This one line contains all the code out of that 1 file inside the Baker module. So we can see very easily that web pack is taken all the code out of these different files essentially place them into this one main dot js file We can find the code out of our index dot js file. If we go down to the very bottom of this file and then scroll back up just a little bit And you'll see right here a comment for src index js. So that is our file. So all the code out of our index .js file is contained inside this eval line right here. You will notice that there's a lot of extra code inside of here as well, just due to how web pack processes are code. If you scroll over to the right barn up, you'll eventually see some stuff around creating that product string. And then our for loop. The body of the for loop. And then eventually the console log of products right there. So at this point in time, all I really want you to understand around Webpack is that we throw in some collection of files. It somehow combines all those files together into one single file, and we get this output named either bundle or main, or any other other couple of names. We can really name that file anything we want, but usually by convention it's called either main js or bundle js. Okay, so now you've seen a little bit around web pack. Let's start to expand a little bit more in the next video.

### Touch More on Webpack

* We've now got our name As file created, but just creating this file doesn't really do us a whole lot. We now want to somehow take this file and execute it inside the browser and make sure that eventually the code inside viewer generates some html that gets displayed on the screen. So we need to load up main dot js into the browser. To do so, we're going to first set up a little module called Webpackdev Server. Webpackdev server is going to take the output from our webpack process and make it available in the browser To set up webpackdev server, we already installed it just a moment ago. All we have to do is make a change to our webpack config file. So back inside of our editor, I'm going to find the Webackconfigjs file. I'm going to add a new section inside of here of dev server. Make sure that server has a capital S. Then I'll put in a port of 8081. That's really important that you use a port of 8081.
* Later on, this port number is going to become very critical. And we need to make sure that we've got absolutely identical port numbers, otherwise you're going to have to figure out some configuration steps on your own. I'm gonna save that file, and then to make sure that I run webpack with dev server enabled, I will also go into my package dot Json file. I'm going to find the start script again, and I'll update the command to webpack serve like so I'll then go back over my terminal and let's run npm run start once again After another little pause, we'll see a message right there, very briefly, that says that our project is running at localhost colon 8081. Now we can access the main dot js file that was created by opening up our web browser. And navigating to local host 8081 slash main dot JS. And there is the contents of our main.js file. You'll notice that we are seeing the contents of the file, which is not really useful to us. We don't want to see the contents. We want to run this file to run the file. We have to create an html document and then reference this main dot js file using a script tag. So let's go through that process as well right away.
* Back inside my editor.I'm going to create a new directory that I will call public. Then inside that public folder, I'm going to make a new file called index.html At the very top, I'll put in a doctype I'll put in an html tag Ahead. A body. And that's all I'm going to put in for right now. You'll notice that we don't have any scrit tag inside of here at all. Well, it turns out that when we are making use of Webac, we are not going to try to manually reference that main dot js file. Instead, we're going to have webpack figure out how to add the script inside of here for us. Let me show you a diagram to help you understand why we're going to do that. Ok so event Actually, we want to load up an html document inside our browser that's going to have a script tag that tries to load up that main dot js file. We should see some kind of scrit tag that says something like source main dot js, or something like that. We could definitely add that in manually. But as you're going to see very quickly, and I can actually kind of modify our index js file to do this very easily, we might eventually have files coming out of Webpack that do not have predictable names. Right now, our file that comes out once it's been joined together is always going to be called main dot js. But it's very. easy to accidentally make some changes to your project, and you're going to eventually want to make these changes And that's going to have web pack spin out some file names that have dramatically different names. That are absolutely unpredictable. So it might have some kind of identifier like this, right at the start of the file name. And these different identifiers are going to be really hard for you to guess. O, we can't really just have a static script inside of our html document, because it would be really challenging for us to guess what those identifiers are always going to be. So instead, we're going to make use of a little plug in called Webpackhtml Plugin. Actually, I think it's called html webpack plugin. This plugin is going to take a look at the different files that are coming out of Webpack. It's going to take a look at those file names and then automatically update that html document we just put together to add in some script tags that specifically reference these very specially named files. So this plugin is essentially going to create for us and add into the html document the rescript tags with the name of 1 K4J43 bundle. and 4 6J3JI.bundle. And the last one right there as well. So this plugin will make sure that we always load up the correct output files that are coming out of webpack. So let's set up that plugin and tell it to modify that html document we just put together To do so, we'll go back over to our web pack config file at the very top. We will import that plugin with html weback lugin And then at the bottom of this object, I'm going to put in a plugin's array inside there. I'll add in new html web ack lugin We're going to pass it in object, give it a template property, and tell it to use the html file inside of publicindex dot html. So this plugin is going to take a look at whatever files are coming out of our web pack process. It's going to find those file names and then add the appropriate script tags automatically behind the scenes to this html snippet right here. OK, so let's save thisWe'll go back over to our terminal, and we're going to restart webpack. We're going to do a control c And then another mpm run start. And now, if we go back over to our browser And go to local host 8081 without any file names or anything like that, and open up our console. We will see our console log from our code O. It looks like the contents of our index .js file is now correctly being executed. We can also make changes to that file at will. So how about back inside of our index dot js file? Let's now do everything from zero up to 5. We're going to do an I lesson 5 right there. That should automatically be updated by webpack So back in our terminal looks like webpacks saw the update we just made to that file. And if we now go back over to our browser, it looks like the console log has automatically been updated as well. And we now see five products being generated Ok, so that is the basics of Webac. We've now gone through the process of having webpack in cat meat together, not really concatenate, but combine together a bunch of different files, roduce 1 output file. And we are now loading that file up inside of our browser. Now, if all this stuff is just total review for you, I apologize for the review on Webpack, but it's really important for you to understand these basics. Because as we go through this idea of module federation inside a wet pack, it becomes super critical for you to understand what is going on behind the scenes with webpac so Just take a pause right here and continue in just a moment.

### Finishing the Product List

* To finish off our products microfront end, we need to make sure that our list of products we've now generated somehow gets displayed on the screen to the user. To do so, I'm going to open up my index HTML file inside of that body element. I'm going to add in a new division with an ID of dev dash products. And closet div off. I'm going to save that html file. I'll then go back over to my index dot js file. I'm going to delete the console log of products. And I'm going to replace it with a query selector For that element we just created, and to show our list of products on the screen, we're going to set that element's inner html property to Roducts. Do notice that inner html, the html right there has all capitals. So let's now save this file and go back over the browser and just make sure that our list of products is being displayed Yeah, there we go Well, believe it or not, that is kind of it for our products microfront ends. We are now generating a list of products and showing them to the user. But that's not really the end of what we need to do inside this project. Right now, we have developed a stand alone application. This thing works by itself, but there's really nothing inside of it to ensure that we can somehow integrate this with our container application. So let's have another quick pause right now. When we come back, we'll figure out how we can somehow plan a random integrating products with the container app once we build it.

### Scafolding the container

*The products microfunded is now in a pretty good state, so now we're going to start to work on our container and then figure out how to integrate these two microfront ends together. So let's start working on container. I'm going to 1st begin by going back over to my terminal. I'm going to open up a 2nd terminal window You'll notice that it is automatically open for me inside the products directory. I'm going to go up one directory. So I'm back inside of our ecommerce folder. So I should see our products roject right there. So once I'm inside of the econ directory, i'll then make a new folder to house everything related to our container. I'll change into that container directory. And then, once again, I'm going to create a package dot Json file with New Mexico init Y Once I've generated that file, we're then going to again install a couple of different dependencies. These are going to be the exact same dependencies that we added in to our products project with one exception. We're not going to add in the Baker module to our container because the container just doesn't need it for any reason. So we will do an npm install. We're going to do html web pack plugin at 4.5 .0. We'll get node mon we don't need to specify a version on that. We'll get web pack at 532 Web packed cli at 410. And then finally, webpack dev server at 311 0 I'm gonna run that. And while that's going, I'm gonna flip back over to my code editorInside my code editor, I can currently only see the product's directory. I'm going to reopen my code editor so I can work on both the products and the container projects at the same time. To do so, i'll go to file and then open I'm then going to select my ecom directory. And open that. Now, if you're in windows, the process will be just slightly different. But ultimately, all we want to do is open up the ecom project inside of our editor O. We should see both our container and our roducts folders.

* Ok so now we're going to do a little bit more setup on our container. The setup inside of here is going to revolve around the exact same files we had created for our products. But some of the files are going to have some different configuration and code inside them. At the end of the day, though, we're going to have to be pretty much the same files in index .js and html file and a web pack config So I'll first begin by creating that index html file. I'm going to create a new directory called public. And then an index.html inside there I'll place my duck tight. An html tag There's my head. My body And we're going to leave it just like that for right now. So one thing I want to point out here is that inside of our container html document, we've got an emty body. And inside of our products, html file, we've got a div where we can render our actual products project. So that list of projects are going to be inserted into that div right there. So it's going to point out really quickly that these two html files are just slightly different. Next up inside of our container, we're going to make another folder of src Inside there, I'll make a new file called index .js. And right now I'll do a very simple console log, and I'll just say, container I'll then save that file and close it. And then finally, we'll make one more file, the Webpackconfigjs file So for right now, this file is going to look kind of similar to what we just did over inside of products. But we're going to very quickly make some big changes to it. O inside of here, we still want to have that html webpack plugin And I'm going to require that from. Html web pack plugin will then do another module exports. We'll set our mode to development. We'll set our dev server. And this time around, for our port, we're going to say 8080O. At this point in time, remember, our roducts roject is on ort 8081. And our container is going to be on 88. And then finally, we'll set up our plugin's array. We'll have a new Html webpack plugin. We'll set the template To be publicindex html Ok, just one last piece of setup inside of our package dot Json file. We'll make sure that we add in our start script. O, I'm going to replace inside of ackage .Json inside the container directory, test, hit start. And whenever we run that, we're going to actually execute our. Wet pack serve like so. Ok, so we've now got products, and we've got container. These are two separate projects. There's no link between them. There's no tie, there's no integration at all. Just make sure the container is working by itself. Let's go over to our command line, make sure we can launch container, and then just try to visit it inside of our browser. So back at my terminal, it looks like my MPM install is all complete. I'll make sure I'm inside my container directory, and I'll do an npm start or an npm run start. Either one is totally fine. OK, so looks like everything has started up I don't see any errors. I might see a warning or two fully fine. Now, to make sure that our container is working correctly, I will open up my browser once again And then I will navigate manually to localhost 8080. And I should see inside my console something that says container like so. Ok, so we've now got two rojects created, and now we need to think about how we're going to integrate them together. So as you can guess, that's going to be a big topic for our next video. So quick pause right here, and we'll dive right in.

## Implementation Module Federation

* We've now got our container and products projects in a pretty good state, but now we need to make use of somewhere from inside of our container. Can you just set up our integration process to start to do inside this video? So let me show you a diagram. I'm watching the steps we're going to go through. Okay, so we're going to go through this one by 1. We're going to go through all these steps rather quickly. And in the coming videos, we're going to go into great detail. I'm going to explain what all these different steps are about. So to get started, we're going to 1st designate 1 application as a host and 1 as a remote. Our host is going to be the application that is trying to make use of code from another project. So for you and I, our host is the container. the remote is a project that is making the code available to other projects. But you and I are remote. Next up inside of our remote, which, again, is products. We're going to decide which modules or files really is what we call them. You want to make available to other projects. So for you and I, right now, this is a really easy decision to make inside of our products project. There's only one source code file available, and that is our src index .js file. This is the only file that we can somehow make available to other projects. So we want to make index dot js available to other projects inside of our overall project. onto step number three. This is where things are going to start to get really interesting to somehow integrate these different projects together. We're going to use a plugin from webpack called the module federation plugin. Like I said, We're going to go into great detail about what all these things are about very shortly. But right now, let's just set up this plugin. To do so, I'm going to find the webpass and face file inside of my products directory. Then. at the very top, I will require in module federation plugin from Webpat Slash Lid slash container slash module federation. Got that required statement. I'll then find my plugin's array. I'll do a new module federation plugin. And we're going to provide a couple of options to this thing. First, we're going to put in a name of Roducts, a Of remote entry dot js. And then finally, exposes. It's opening to that. This is gonna be enough. I'm gonna Yes. And then finally, expose this. This is going to be an object with a key of dot slash products index and a value of dot slash src index Now I'm sure all these different options right here, right now, look a little bit mysterious. Like I said, Don't worry. We're going to come back and understand what this is all about. O, I'm going to save this file and then close it. Now we'll move on to our next step inside of our host, which is our container. We're then going to decide which files we want to get from the remote. So in our case, once again, really easy decision. There's only one file available. The only file that we can get access to inside of our host is the index dot js file inside of products. So we want to get access to that file Once you've decided upon that, we're going to set up the module federation plugin inside of our host as well. So inside of our container, web pack config js We're going to again require Module federation plugin. From web pack lid container. Module federation plugin. I'll then go to my plugin's array. I'm going to set up in a very familiar, very similar way. So new module federation plugin. And it will pass it a couple of options So in this case, we're going to add in a name of container. And then a remote that's going to be an object. Open in Roducts, and I'll put in a string gear. And the string is going to look a little bit confusing. So please double check your spelling and your all your typos inside of here. We're going to put in products at http colon slash slash localhost 8081. Remote entry js OK, there's our setup inside the host Now, this next up, once again, a little bit confusing. Don't sweat it inside of our host. We're going to do a little bit of a refactor. All we have to do inside of our container directory, we're going to find the index .js file. I'm going to rename that file to bootstrap. Now we've got bootstrap dot js. And then inside of src, I'm going to make a new file, also called index .js And inside of here, I'm going to put in an import function call. So notice we don't have an import statement. It's an import function call. And we are going to write in there dot slash bootstrap like so And then finally, inside of our host, we're going to import whatever files that we need actually need from the remote So for that, we're going to try to figure out, hey, where do we actually want to make use of our source code that we're importing from products? Well, we probably want to get access to all that source code inside this new bootstrap dot js file. And I see probably, but that's probably not really clear why I say probably just yet. Don't sweat it right now, just inside a bootstrap js at the very top. We'll put in an import of products, slash products index, like so And that should be it OK for the 5th time in this video. I just want to mention I know a lot of this stuff is probably really mysterious, really confusing. Don't sweat it. You can go over it step by step. I apologize for repeating that, but just want to make sure it's super clear. Now, to test everything out, we're going to go back over to our terminal and restart our web pack processes. So back at my terminal I have two terminal windows open. I've got one right here for my container for my products. And then the other 4 container. But I'm going to stop both these with the control So here's products folder and the container folder. And inside of both them, I'm going to do another npm run start. OK, so now we're ready to test everything outside the browser. And I want you to know that when we run this in the browser, we might end up seeing an error message. But that's truly okay. We're going to fix it up really quickly. So back inside my browser, I'm going to navigate to local host 8080 And then once there, I'm going to open up my console, and I might see some kind of air like this. Something that says, cannot set property inner html of null. So we're seeing this error right now because we are trying to run some code from our products application. If we go back to products and find index js, remember that when we load all this code and execute it, we try to find some element on the screen with an id of Devroducts. And then we try to set its inner html. So right now we are running this code inside of our container project and inside of our container project. We don't have an html element with that selector. So to get our code to work, we're going to very quickly go into our public index dot html file inside of container. And inside that empty body, I'm going to add in a div With an id of dev dash products. On and save the file. Flip back over. And sure enough, at local host 8080 we now see our list of products on the screen. Remember, localist 8080 is our container application. We can also see a console log of container right here. So I think at this point in time, it's pretty clear that we are inside of our kind of container application environment, but we have loaded up and executed some code coming from our products application. So this is definitely good, but a lot of mysterious code. Let's take a pause right here and then start to figure out what is going on in the next video.

### Understanding Module Federation

* We've now set up some integration between our products project and our container. Let's now take a look at justice our configuration around products and really understand what the module federation plugin inside the product's webpack config file is doing for us. So I just want to focus on this module federation plugin inside of products for right now. OK, we're going to take a look at a couple of different diagrams, but first I want to go back over to my browser. I'm still at local host 8080. Once here I'm going to open up my console. I'm going to go to the network tab. I'm going to filter requests by Javascript files, so now we're only going to see requests that are trying to load some Javascript and then I'm going to refresh the page. I'll then see a couple of different files are being loaded. Now remember, we're at local host ad right now, which is the port for our development server, for our container alication On the system files, I'm going to right click anyone of the headers and then enable the url column. Once I get that column up, I can take a look at where all these different requests are being made to. You'll notice that three different files are being made to localhost 8081 which is where our containers meet our roducts development server is running. So when we go to our container application right now, it looks like we are loading up three different files from products. 1 file is called remote entry. Another is called source index js. And another has a really long name that seems to be related to our faker dependency. Generally, we've identified these three different files. So we are loading up from our products project. Let's take a look at a diagram and understand what they're all about. Ok, so here's a diagram of what's going on inside of Justice. Our products roject for right now.
* So we still have products. We still have an index js file inside there that makes use of the Faker module. When we start up Webback with this module federation plugin, we are now emitting two different sets of files. We are still bundling up that index dot js file as usual. And we are spitting out a main dot js file that includes everything from index along with all the dependencies that that thing requires. I only mention this because that means that we can still run our products project in isolation without having to worry about running a container or any other application So we can still develop our entire products application in a kind of standalone environment. By adding in the module federation plugin. However, we are now emitting a second set of files. The Module Federation plugin is causing us to output another set of files, which are the remote entry file, source index and something around Faker as well. These are the three files we just saw inside of our network request log. The first file remote entry js is a javascript file that contains kind of a manifest of sorts. It lists all the other files that have been emitted by the module federation plugin, and also has directions on how to make use of them. The remote entry js file can be thought of as being kind of a set of directions for other projects, like our container. The set of directions tells the container how to load up some source code from the products project So that promote entry js file will tell our container that if the container needs that sourceindex js file, well, here's some directions on how to go and fetch that file. And if it needs something around the faker module, here's some directions on how to fetch this file as well. The sourceindex .js file in the Fakerjs files. Once again, we saw these inside of our network request log just a moment ago, or essentially identical to the index js file we've got inside of our roducts project and the actual fake dependency. But they've been processed by Webpack. So rather than just having the exact code that we have inside of our code editor, such as this right here, wet pack will take all this code and convert it so that we can make use of modules like import statements and stuff like that inside the browser. Long story short, the version of this sourceindex .js file and this faker stuff that Quit from the module federation plugin can be safely loaded and executed in the browser. Let's go take a look at the source code for source index JS inside of our browser right now, just to see what it looks like once it's been processed by the module Federation plugin O back over here. I'm at my network request tab once again. Here is source index JS and I can see that it's been loaded from our products project. If I click on that. And then go to the either preview tab or response We're going to see some source code inside of here that essentially says, here is the source code from the actual sourceindex .js file. All the source code from it is inside this eval string. And inside there we can see that there's some direction saying, hey, we need to load up faker. And then eventually, once we load faker, we're going to create that product string, do our for loop, build up the list of product names inside of a div, and then eventually render that output to some element that's inside the Dom So you can see very easily that. this file right here has all the same code from our real source in Xjs file, but it also has some stuff and checked it into it by weback that says here's all the other dependencies that this file requires to run safely Ok, so at this point in time, we've really established what's going on with the module federation plugin when it is running in a remote mode. Or essentially, when we are telling the Module Federation plugin that we want to take some code out of our current project and make it available to other projects, the Module Federation plugin spits out this set of files that includes a set of directions on how other projects can get access to the source code of products. So now that we understand just that piece, let's take a pause here and then understand what the same plugin does over inside of our container application.

### More on Module Federation

* Let's now take a look at the module federation plugin does for our container application. So we're going to take a look at a very similar diagram. The first thing I want to address is the fact that we had created a 2nd file called bootstrap.js He did the integration process. So back inside of our editor, here's my container application. We now have a bootstrap js file, which contains our actual alication code and an index dot js file. And inside of index dot js, all we are really doing here is importing the bootstrap file and nothing else. And what's more, we're using some different syntax for the import. So what is this index dot js file all about? And why do we add it in? Well, this really gives Webac the opportunity to realize that before executing that bootstrap dot js file, we have to go and fetch some code from the products project That's what the index .js file is for. It is just to allow webpack that opportunity to go and get some additional javascript and make sure that we've got the project code or something that products code ready, along with the faker code ready as well. Before we try to actually do something with it, when we actually execute the contents of the bootstrap dot js file, the expectation is that we will have access to this module in all the different dependencies that it requires. So if we try to go directly into our bootstrap dot js file, in other words, if we try to execute this first, we would end up with an error. We would end up with some kind of message that says, sorry, but we don't have any code for products. We don't know where to get that code. We don't have it available. So by adding in the index .js file, we are just giving web pack an opportunity inside the browser to go and fetch some dependencies from products before actually executing the code of bootstrap. We can kind of see this rather easily inside the browser. So if we go back into our browser, open U that network request tab again, we can take a look at that mainjs file. O, if you click on it And go to either a preview or response. You can then go down to the very, very bottom the file, and then scroll back up just a little bit. And you might see an entry right here for source index .js. This is the index.js file inside of our container. We once again have this string with all the code from it. You'll see that the code has been transformed a little bit. And so now, rather than just having something that says, import bootstrap, we've now got something that says, require in bootstrap js or source bootstrap js. And then. after that, try to execute the code inside it. So Long story short, once again, this is really just giving us a really giving web pack the opportunity to go and fetch some code from products before running our index.js file. Ok, so back over to this diagram. So again, inside our container, we've got the index dot js file that's really generating main dot js. And then our bootstrap is really being output as a separate file. We first run mainjs, that's going to try to fetch some additional code from products and then execute the code inside of bootstrap js. Now let's start to put our container and our product stuff together inside of one diagram and understand the real flow of what's going on Ok so in in the browser, we've got a series of steps that go on. We've then got whatever is coming out of our webpackdev server for a container. And on the right, we've got products. When we first go to localhost, 8080 the first thing you do is download and execute the main dot js file from our container. Once we execute that file, webpack then sees a require statement saying that, oh, we need to import and somehow execute bootstrap js. So wet pack is going to start to download that file. As it starts to download that file, webhack also realizes that it needs something from the product's project in order to execute bootstrap. So simultaneously, as it starts to download bootstrap dot js, web pack inside the browser is going to fetch remote entry from our products application This remote entry at JS file says that in order to run bootstrap js, we have to download source index.js and faker from products as well. So web pack is going to download. Source index js and everything for faker Once it has completed the download for bootstrap or source index and for faker, now it finally has all the code that is needed to actually execute bootstrap. So it runs the code inside of bootstrap. We've got everything from products including the source index.js file in Baker over there as well. Another way that we can really verify this entire process is by taking a look at the sequence of requests that are being executed. O back over here, inside of our networkrequestlog, we can take a look at the waterfall chart. So inside of our waterfall chart, you'll see that the first game happens is we download and execute the main dot js file. Once we execute that file, we then realize, ok, we also need something from products, and we need that bootstrap file. So simultaneously, web ack goes to download the bootstrap file, and it also knows that it needs to download the remote entry file to figure out how to get some code from the products project. Once it gets the remote entry file, it then sets up another two requests to get the Bakerjs stuff and the index .js stuff from Roducts. So it's only when these two requests right here are finished and we get the ability to execute the code from products that essentially all three of these different files are ram. The bootstrap Baker and index .js That's what's going on behind the scenes. Ok, so all the stuff I know is pretty intense. There's a lot of stuff going on here with this module federation stuff. And it actually even goes deeper than what I presented. It turns out that there's a lot of extra kind of corner cases around handling dependencies for stuff like Baker. We're going to explore some of that as soon as we start to add in our final microfund end, which is the cart application. So let's take a pause right here. We're going to come back the next video and make 1 or 2 changes to our products project. I want to point out one or 2 things around it that is not quite great right now. In some ways, we could probably improve some of the structure of our code So could pause, and we'll do some improvements in just a moment.

### Understanding Configuration Options

* At the end of Video I mentioned we're going to change some code inside of our products project, but before we do so, I want to explain some of the options that we provided to our webpack configuration really quickly. So specifically the options we provided to the module Federation plugin, we're going to first take a look at the options we provided to our container. So on the side of container, web pack and big dot js All right, here we go So the first option we provided was the name. The name is not being used whenever we are creating a host module. Remember, our container is a host. It is trying to use some code from some other projects. A name is only required when we are creating a remote. Remember, a remote is something that is trying to share code with the outside world. Even though this name property is not used because we are inside of a host, it is usually convention to add it in any ways. Next up, we have a remote section. The remote controls how web pack is going to try to decide whether or not to load up that remote entry file. Rather than taking a look at all the notes on here, let me just give you a very practical example of what this remote section is all about OK, so inside of our container project, I'm gonna find the src bootstrap dot js file. You'll notice that inside of here we've got an import statement that begins with a word product's O. When we build our project and it's compiled or processed by Webpack, Wepack is gonna see that we are trying to import a module that begins with the word products. If Wepat cannot find a product's dependency inside of our node modules directory, then it's going to take a look at the module federation plugin, specifically the remote section. Inside this object, it's going to see if there are any keys inside of here that have the word products. And sure enough, there it is, right there So this word products matches up with this key products right here. This tells Webac that to try to implement this imort or try to actually get access to this code, webpack needs to load up the remote entry file that is listed right here. So if we ever wanted to change how we refer to our products project inside of our container, we would change the word products right here. And this key right here. Let me show you an example of that. Maybe we want to change this to products app or something like that. Maybe that's how we want to import this thing. To do so, we would have to also go into our webpack config, find the word products right there and change it to products app I can then save both these files, and then go and restart my webpack process really quickly. If I then go back over to my browser, I can refresh the page, and everything still works as expected. So you only have to change this key right here if you want to change how you write out the import statement for this outside project. I'm going to very quickly change this back to Roducts and Roducts by so Okay. So that is the purpose of the key of that object. And the value is a string on the right hand side of that at sign is the url. And as you guess, that is where we should go to try to get the remote entry file to figure out how to load in some modules from this outside project The word on the left hand side of the at which says products is related to some configuration that we put into our web packs config firstly, our products, webpack config file A word on the left hand side of the app, right there. Products is a tricky little thing. I'm going to show you a little bit more around that in just a moment. So we're going to forget the word products right there for justice a moment. Okay, so that's it for our container web pack. File. Now let's take a look at our webpack config that we place inside of Roducts. Here's the diagram for it. I'm going to also open that up inside of my editor very quickly
* Ok, so now here we've got a name of products. That product's right there, that string has to be identical to that product string right there. That's what needs to match up. So if that string is not identical to that string inside the remote config, nothing is going to work as expected. Let me show you this in practice very quickly. So I'm going to open up my products, web pack and fig. I'm going to find that name property, and I'll change it to about just like my products like so I'll then save this. And I'm going to restart my web pack processes once again. I'm then going to go back over to my browser, and now I'm going to see this nasty air here. It says, sorry, but something went wrong. So again, the rule of thumb here is that name of products right there has to match up with wherever we are trying to make use of this module from has to be identical to that string right there. That's pretty much it. Now, beyond that, we've also got a file name that controls the name of the remote entry js file. There's just about never a very good reason to rename this file. I recommend that you just always place it as remote entry dot js. And then finally, we've got exposes. So the exposes object right here controls which modules or which files inside of our products project that we're going to expose to the outside world. So if we had many different files inside of products, we could choose to export all of them, or maybe just one of them, or as many in between as you want So in this case, we are saying that we are going to expose a module called products index. And if anyone tries to import something called products index, we want to give them the SRC Index file. So let's take a look at that as well. Back inside of our bootstrap js file. Remember, we had said products slash products index. So wet pack is going to get that remote entry file inside there. It's going to try to find something called Roducts Index. Inside of our webpack and fake for products, anytime someone asks for products index, we're going to instead give them source slash index, which is the index file inside of our products project. Now this line right here is probably going to be one of the most confusing things for you. You might be saying, wait, we are. We're essentially renaming something. That's what's going on here. It's an alias and you might be saying, wait, why would we ever do this? What's the point of it? Why don't we just expose everything inside of products and say, hey, that's it. You can just reach through and just take out any file you want, and it can have any arbitrary name. The reason that we have this kind of aliasing ability right here is because there might be some scenarios where the name of a file inside of our products project might be kind of only meaningful in the context of products. Let me give you a really quick example of that So crypt diagram. Here we go. So let's imagine that rather than making some kind of products thing, maybe we're making some kind of charting library, a library that generates charts and shows them on the screen or something like that. Maybe inside of our chart project, we've got some different files organized like so. Maybe we've got a bar chart directory and inside there is an index dot JS file and that file has all the code required to create a fire chart. Maybe we've got another one for making a line chart, a radar chart and so on. And so all these different files are named something like bar chart slash index line chart slash index and so on. This is a really small thing, but we might not want to write out inside of our container project something like import bar oregon, really be charts bar chart index. Adding on the index on there at the very end is just not super necessary. We don't really gain anything by putting on the word index and so maybe you would be just ever so slightly more convenient if we could just write out something like charts slash bar chart and be given that bar chart slash index .Js file. So that's. all. So that's all this kind of aliasing thing is doing for us is just making it so it's slightly more convenient to choose exactly the names and paths for all these exported files. That's all. At the end of the day, once again, all this really means is that if someone asks for the products index file, give them the source index file. And so again, back inside of bootstrap js, we ask for products index. And we got back source index.js from products OK, so again, if that part, that little aliasing part right there, is confusing, I apologize for that. But it's just reality. It is what it is. O. K. So that's a deeper dive into us configuration. I apologize for the last video being really long and this one being really long, but hopefully you've now got a better idea of what's going on with module federation. So let's take a pause right here and continue in just a moment

### Scaffolding the Cart

* Let's get started on our cart microfront. As a reminder, this little cart feature is just going to show the very simple text right here. This says something like you have one item or 2 items or whatever in your cart. The actual number is going to be randomly generated, so we don't have to worry about having any actual adding functionality or anything like that. The code for the card is going to be extremely similar to the products list, but as soon as we add in the car, we're going to start to run into a couple of difficulties. We're going to have to think about some different ways to resolve them. So let's get to it. Back inside of my code editor. I'm going to first begin by creating a new folder called cart, then to save just a little bit of time. I'm going to copy the package dot Json file from products. So here's a copy, and I'm going to paste it into cart Then inside the cart package dot Json file, make sure that you've got the cart one open. We'll just change the name of the project to cart. This name is not actually used anywhere. It's just a for record keeping. So let's now go over to our terminal. We're going to open up a 3rd terminal window that's going to be dedicated to running our cart project, and we'll install dependencies into it. So I'm going to open up my third terminal window. I'll change into the cart folder, and then do an empty install inside there Once I start that up, I'll go back over to my editor, and we're going to essentially create the exact same files inside a cart as what we have inside a roducts. But I would really encourage you to write these all out by hand, as opposed to just doing some copy paste, because it just builds a little bit of muscle memory. So let's get to it. I'm going to first create a new folder of public And I'll make a new file inside there of index html. So once again, do a doctype Html Ahead A body And I'll place a division with an id of dev dash cart. So that's going to be eventually where we try to render our current application into. After that, I'll make another new directory inside of cart. Of Src Inside there, I'll make a new file of index js. And inside of here, we'll have some code that's going to just require in or import in Baker. We're then going to generate our fake text to say, you've got so many products. And once again, just show it into that div element that we just created a moment to go So at the very top, I'm going to import in Faker All then put together a variable. We'll call it. How about message? How about cart text and call it anything? It doesn't make a big difference. I'm going to make this a temlate string. Put in a division, and I'll say, you have an dollar sign. Curly braces, Baker, random number. And then. items in your cart Let me zoom out just for a second so you can see that entire line So then after that, we're going to try to take that text and render it into that division right there. We'll do a document query selector. Cart dev. That the inner html to cart text like so OK, that's it. It's now our last thing inside of cart. I'll make a new webpack config .js file. So again, this is going to look very similar to one we just put together for our products application. At the very top, I'm going to require in htmlweback plugin I'll get my module federation plugin Then my module exports Set our mode to the development Start up a dev server. And then remember, we've already got a development server running on port 8080. That's our container. We've got one on 8081. That's products. So we will put our cart on 80 82. We'll then set up our plugins So for plugins, first do our new module federation plugin Remember, we need a name. Look at a name of cart. A file name ofremoteentry.js. Again, really no great reason to use any file name besides that. And then exposes And we'll do a string U dot slash cart show. And anytime someone asks for that cart show file, we're going to actually give them. Source index Or just index like so. And then finally, after that plugin We can put in our new html web app plugin. And there's our template of public indexhtml OK, that's it I'm going to make sure I save all these files, and then let's try to run our cart in isolation just to get started. O, I'm going to go back over to my terminal. Looks like my M install process is complete. So inside of my card directory, i'll do in npm. You know what? I just realized we forgot to put in our start script. Let's go back over to our editor, open up that package dot Json file. Oh, wait, no, we copied it. So it's good to go. My mistake. So, yes, we can go into our terminal and do an NPM run start. Now we should be able to open up our browser and go to local host. 8082 So I'm going to go to local host 8082 And it looks like I probably put together that id for that element incorrectly. That's my guess here. O, I'm going to just go check that out really quick. Ears cart dev. Oh, dev dash car. Yeah, that's the reason. So one was dev dash current, the other was car dash dev. It's gonna fix it up really quickly Now, if I go back over and refresh, here we go. So I've got 23,000 items in my cart. That's a lot of items, but whatever, it works for the purposes of our a okay. So we've now got cart running in isolation. Now quick pause right here. We're going to start the integration process into our container in the next video.

### Cart Integration

* Let's start to integrate our car project into our container. To get started, I'm going to open up the container webpack config dot js file. Inside of here, I'm going to find the remote section. I'm going to add in another property of cart, and then I'll give it a string of cart at http colon slash slash localhost. 8082 Remote entry js Then inside of my container, src bootstrap .js file. I'm going to import cart. slash cart show. So let me just give you a quick reminder on how this import statement works. First, webpack is going to see the word cart. The word cart is going to match U with the cart that we just added in to our container webpack config file. So it's going to see cart right here. And Webpack is going to understand that it needs to load up this remote entry js file in order to access our carved code. Once that file has been loaded up, we're then asking for specifically the cart show module Our current project doesn't actually have a module called cart show. So you might recall inside the cart webpack config file, we had set up this alias inside of here. So we had said that if anyone ever asks for cart show, we're going to actually give them source slash index. That's how we are ultimately getting cart source index.js into the context of our container. Just a little note on that aliasing feature. At this point in time, you can start to kind of understand that if we had an import statement of something like roducts slash source index and cart source index, it's kind of hard to understand what's going in here going on here with these imports. Source index doesn't really tell us what this file is all about, but if we have file names like products index and cart show, a lot more clarity, I could look at this name right here, and I've got reasonable suspicion that this is probably going to show a list of products on the screen and cart show is probably going to show some details about some particular cart on the screen. Okay, so this looks good. The last thing we have to do is make sure that when we import in cart show and run all the code inside there, we need to make sure there's some actual dom element that our cart is going to be able to render into So inside of my container, publicindex dot html are going to copy that division right there. And put down another division with an id, and I forgot what we ended up calling it. Kids, carpet. You'll notice that they're opposite in here. No big deal. We're actually going to come back and change these disks in just a moment Ok so I'm going to save all these files, and let's go and restart our container. So I'm going to find my container running at the terminal. I'm going to stop with the control C and then do another New Mexico run start Now we should be able to go Localhost 8080. And see both our product list and our cart up here on the screen. Awesome. So that means that we are loading U code from those two sub projects into our container. Now this is definitely really, really good, but there are some other considerations I want to throw out there, some stuff that's a little bit awkward about this project. I want to go into the next video.

### The Development Process

* We've now integrated all three projects together. So at this point in time, I want to take a very quick pop And just make sure that it's crystal clear how you would develop an application like this in the real world. Alright so quick diagram so we're going to imagine that maybe we have one engineering team in charge of each sub project O for team #1 they might be in charge of Roducts Team #2 might be in charge of cart and team number three might be in charge of the container teams number one and two can develop their entire application in isolation. In other words team number one can develop products by itself and they don't really have to care about what any other team is doing. They can have all their own dependencies all their own tooling The only requirement is that they make use of wet pack and they make use of the module federation plugin. That's pretty much it. So for team number one in order to develop their project all they have to do is change into the products directory run NPM start inside there they can then navigate to local host 8081 and see their application appear on the screen. They can then develop their products application in isolation. Same thing. 14 number two. The only difference is that they're going to go into the car directory and their application will be running at localhost 8082. T number three is the only one that's going to have any amount of crossover. The team number three would need to make sure that all three sub projects are running. So they would need to make sure they run npm start inside of them Art's products and container. Then they would navigate to localized 8080 and they would be making changes only to the container alication, just to make sure that they are showing the correct subapp in the correct part of the screen. Make sure that navigation works and stuff like that. We'll go into more on what the container's goal really is over time. Right now. Remember, we're just saying that's showing the other 2 applications. Now there is one other thing you want to make sure that's really, really clear, because you might be a little bit confused around the existence of these html files Ok, same diagram. I'm just a little bit lower, and I add on these red boxes. So just to make sure it's really clear, our products and car applications have indexhtml files inside them. Those html files are only used during the development of these sub projects. They're only used to load up products and cart and get them visible on the screen of the browser. So inside of any kind of production environment, we do not make use of the html files inside of products or cart. Instead, we load up the javascript only from products in cart into our container. And so ultimately, it is the html file inside of container that will be used during production. So again, we only really worry about the html files in product and cart during development. And for that reason, those html files are usually going to be very, very simple and very sparse. We're not going to really have a lot of markup in them. In general, we're just going to have some kind of root element where we can render our application into. Then we just make sure that our app works as expected. Okay, so hopefully this entire development process is just a little bit more clear now. And there is just one or two more changes, and other topics I want to go into in this application. So click ause a little bit more

## Sharing Dependencies Between Apps

* In this video, we're gonna take a look at sharing dependencies between different sub projects. So as quick reminder, both our products and our cart rojects make use of the Baker module. Let's take a look back inside of our browser and just see how Baker currently is being loaded up. So back inside my browser at localhost 8080 I'm going to open up my network request tab, go to javascript or filter by javascript requests, and then do a refresh. Once I do so, you'll notice that there are two files being loaded up called something like vendors node modules, baker So at present, because both products and cart are making use of this dependency, they are both loading their own copy of it. This is definitely not very good, especially because the faker module itself is very, very large. You'll notice it's about 2.9 megabytes large. That's extremely large, and we really want to make sure that we do not load up two copies of it if we can somehow avoid that So if we could somehow figure out some way to get both Baker and cart versus you both cart and products to use the same copy of Baker, that would really be fantastic. And it turns out we can do this very easily by using the module federation plugin. Let's first begin by taking a look at a diagram that's just going to explain the series of actions that are going to occur once we make a little configuration change. So when we start up our application, the container is going to try to find the remote entry file for products and the remote entry file for cart. These remote entry files are going to mention that they both require the fake or module. So at that point in time, the container application understands that we need to get a copy of faker in both of these different sub apps of cart and products need that copy. So the container can do can decide to only load up a single copy of Baker and then share that single copy with both cart and products. So you'll notice that we're getting some really crazy kind of coordination between these different sub applications through the module federation plugin. It is the module federation plugin that is injecting or adding in additional code to our project to help instruct the container on how to make the series of decisions. You and I do not have to write out any code that makes this happen. We just have to change a couple of configuration options to make this process occur Just do that right away Back inside my editor, I'm going to find my product's webpack config.js file I'll find my module federation plugin and then I'm going to add in a new option to this thing of shared And I'll put it inside of an array, a string of Baker. I'll then save this file and then go over to my cart weback and big js file. So here's the cart. And over here, we'll put in shared Baker as well. So all we're doing here is saying that if we ever try to require in or import the Baker module, let's try to share it. Let's see if some other application inside of our container has already loaded up the faker. If we have, then we're going to get a preloaded copy, and we're not going to try to fetch our own independent copy. You'll notice that we do not have to make any actual changes to a container. The container is going toAutomatically see that we're trying to share the Baker module. Once it loads up the remote entry file or card and Roducts before we test this out, we do have to restart webpack. So let's do that very quickly. We only have to restart the products and the cart applications. So I'll make sure that I restart my roducts, weback rocess. And by Kurt Weback Rocess as well Then after that, I'll go back to local host 8080 refresh the page, and you'll see that now we are only loading U1 single coy of faker. Awesome. This definitely works. But unfortunately, we just broke something else. So you can open up a 2nd browser tab and go to local host 8081. Remember, that's going to try to load up our product application in isolation. And when we do that now, if you open up your console, you'll notice that nothing appears on the screen. And we get this nasty error message that you're probably going to see very frequently. So I want you to remember this error message. It says, shared module not available for eager consumption. So what's going on here Well, remember, when we load up products in isolation, the first file that really gets executed is our sourceindexjs file. And inside of here we have some code that says, get access to faker right away, like we instantaneously want Baker available inside this file, because we're going to call some functions on it right away Unfortunately, when we Mark Baker as a shared module, that causes it to be loaded up by default asynchronously. So when we load up our index.Js file, we do not yet have Baker available. This is not an issue when we load up products through our container, because we load up products through container. We are first loading up the remote entry file for products and remote entry file has some code and configuration inside of it that says, hey, we need to get access to index js and to run that file we need. So when we load up our application through remote entry, we don't run into any issues because webpack can very easily have the time and say, Hey, we need to get both index js and the module. But when we load up products by itself, we're getting indexed right away. We're trying to use Baker right away, and we end up with the error message. That says sorry, but we don't have this module yet, because we are trying to use it instantaneously, but we haven't loaded it. So that's why we are seeing everything work over here through our container. But not only try to run products through isolation O, obviously we need to fix this because we still want to run roducts in isolation, even though we're trying to use a shared module. So let's take a look at how we fix this error message in the next video.

### Async Script Loading

* So how are we going to fix up this error message? Well, it's really simple. We're going to use the exact same pattern that we used inside of our container project. Remember, inside of container, we have an index dot js file that has an import for bootstrap. This import statement is called as a function, rather than being a kind of standalone import. Like so when we use import in this kind of function form, it's going to load up the bootstrap file asynchronously. O, we're going to do the same kind of thing inside of Roducts as well. By doing that, we're going to give web pack the opportunity to take a look at what files this code requires to run successfully. And when we give web pack that process or that ability to see what we need to run this code, webpack is going to have the ability to load up faker before we try to execute any of this. So it's all thanks to just putting in that little import statement. So inside of our src directory, inside of products, I'm going to make a new file called bootstrap.js. And then going to open up the index file. I'm going to cut everything out of here and paste it into bootstrap and save the file Then back inside of index js, I will import .slashbootstrap. Now I know this might seem like a really funny, really pointless little step. Again, all this does is give weback the ability to asynchronously load up the bootstrap js file. And because we are loading up that code asynchronously, webpack has the opportunity in the browser just to realize that before we run this code, we also have to fetch faker. So let's see both these files, then go back to the browser. I'll then refresh this page. And now everything works. And if we go to our network request tab, we can see exactly why that is. So we can see that we are now attempting to get our main dot js file. And inside of our main dot js file, we've got a ton of stuff inside of here, but down towards the very bottom down here, we'll see. our sourceindex.js O. Here's the long line of code. So we've got this import bootstrap js, and it's that import statement right there that gives Webac the ability to take a look at the bootstrap file and understand what the bootstrap file needs to run. So now web pack inside the browser understands to get that file, we first need to get a copy of Faker. So here's the load for faker, right here. And then we can actually go ahead and download and run the bootstrap js file. Now, if we go back over to local host 8080 and refresh the page, you'll notice that everything pretty much works identical over here as well. We do have an extra request for bootstrap, so we are now loading up an additional file inside this container environment. But when we eventually go over to production, we're not going to have quite so many requests going on Ok, so this definitely looks good. We do have to repeat the same process for our cart as well. If you try to go to localhost 8082 you'll currently see the same error message is, once again, we're trying to make use of faker before it's actually been loaded into the browser So back inside of cart, we're going to do the same thing. Inside of src. I'll make a bootstrap js file. I'm going to cut everything from index js and paste it into bootstrap
* We then save that We can now go back over and at local host 8082. Once again our CART application works I wanna repeat just for the second time. I know this seems like a kind of pointless little step. It's just about introducing some asynchronicity into loading up our javascript code. And that gives Weback the opportunity to figure out what all of our different files actually need to run successfully. Okay, so now that we've got this all fixed up, I wanted to have a little bit more discussion about how sharing modules between our different sub projects works. So let's go a little bit deeper in the next video.

### Shared Module Versioning

* Right now, cart and products are using the same exact copy of Faker when we load them both up through our container. So once again, we can see that very easily by going to localhost 8080 refreshing the page. And we're seeing only one copy of the faker module being loaded here. But there's a really quick question that starts to come up once you consider this dependency being shared between both products and cart. Remember, these two projects might be developed by totally different engineering teams, and they could very well decide that they want to use different versions of the Faker module or any other module for that matter So what would happen if one project tried to use a very specific version of Faker and then the other tried to use a completely different version of Faker? What's going to simulate that process and see what happens? So over inside my terminal, I'm going to find the terminal window that is running at my car project right now. I'm going to stop weback. I'm then going to do an np install Baker four point. 1 Just so you know, our products application is using version 510 of Faker. So we now have two very different versions of Baker being used across our different sub projects. Let's now start our car back up. And then refresh the page at localhost 8080. When we do so, we'll now see that we are loading up, once again, two separate copies of Baker. This is desirable. This is what we want to have happen. We do not want to use our different or want our different projects to try to use the same copy of Baker if they both expect to have different and very specific versions. If we were trying to make use of version 4.1 .0 inside of our cart, there might be a very good reason for that. We might be relying upon some feature that might break inside a version or even be removed inside a version 5.1 .0 So if we have different sub projects that require different versions, completely different versions, we want to make sure we load up different copies. And that is what is occurring here. So this is definitely good and expected behavior. Ok, so you might be curious, how does the version system actually work? Well, the Module Federation plugin is going to take a look at the versions of these different modules that you specify inside of your package dot json file. So inside of products, you've got version 510 right here. And inside of card, we've got version 410 The Module Federation plugin is only going to decide to load up different versions of these modules if your version specified right here are significantly different and do not match. Just so you know, this little carrot right here means that we can use version 410 or any other minor version or patch version. So 410 with a cure in front of it is equivalent to, say, for six, zero or 464 or whatever else. The only thing that can't change, we've got the carrot right there is the major number. So that's the 4th at the very start. So let's try tweaking these versions and see when we can get module federation plugin to once again share these two versions, even if the exact number right there is slightly different. But for that, I'm going to go back over To my terminal window. I'm going to stop cart once again and do an npm install Baker at 5.0. So now cart and products have the same major version. They're both trying to use version 5. Roducts is trying to use version 510 but because we've got the carrot in front of our version, that means version 510 is okay to use with version 5.0 .0. So I'll now do another npm start. I'm going to go back over to local host 8080 refresh. And then you'll notice, once again, we are using the same version. First thing is the same copy. Technically we like have or we have the same copy here, even though they want to use slightly different versions. But because of the little matches we put on there, that little carrier in particular, we're saying that version 5.000 right here is compatible, or can be used with the products by .1 .0 So the little carrots there, or you might also see the squigglies, which refer to the mutable patch version. That's where these things start to get a little bit more important Ok so now we can see that we can work with different versions between these different modules. Definitely a fantastic feature. There's 1 other thing around deendencies I want to show you in just a moment.

### Singleton Loading

* There's one more thing I want to show you around sharing dependencies. So back inside of my cart, web pack and fig file, looking at this shared option right here, our faker module can be loaded up several different times inside the browser without any problem whatsoever. In other words, we can load faker, and it's still going to work even if we load it into the browser multiple times. There are other modules, however, and the most important of which is react, where we cannot load them up multiple times inside the browser. If you try to load up multiple copies of react, you're going to eventually get an error message from react that says, hey, you've got multiple copies of react running. Don't do that. So they're. might be some scenarios where we want to have different versions of a library which would imply that we want to load up different copies, but we might want to actually prevent that behavior, because if we do load up different copies, we would end up with some kind of error. So let's simulate that and Justice see what happens and how we can make sure that we only restrict and get just one single version, or at least get some kind of notice saying, hey, you probably have something wrong going on here. So to get started, I'm going to find shared right here, and we're going to define these shared options using a slightly different syntax. Rather than putting an array of strings, I'm going to put in object with a key of Faker, and then we're going to put in here Singleton true. Sealed and true means that we only want to load up one single copy of faker no matter what. Only 1 copy So I'm going to save this. I'll then go over to products webpack config. And I'm going to make the exact same change. Once again, we're going to restart our webpack processes. But here's carts. I'll do an impient start. Here's products. I'll do an npm run start And now, if I go back where my browser and refresh, once again, we're going to see that we are only loading one single copy. O, now let's try to get Weback to try to load multile copies and see it kind of conflict with that Singleton rule. Remember, webpack will attend to load up multiple copies of a module if we try to specify multiple different incompatible versions. So let's go back to cart. We're going to reinstall version 4.1 .0 of Baker. And we're going to see how the versioning stuff plays out with the Singleton rule. We'll just see what webpack does. Tobacco in my terminal, i'll find my cart terminal window We'll do an empty install Baker at or 1.0 again. So now we have incompatible versions and a module federation plugin is going to want to load two separate copies of Faker. But like I said, we also put in that Singleton rule, which says, don't try to load up single copies. So let's just see what occurs Ok so I'm going to refresh. We'll see that we still get one copy right here. But if you open U your console, you'll see a big warning message right here. O, the warning message says that we are trying to get version 5.1 .0 or we have version 1 5 .1 .0. But we want version 4.1 .0. So this is the sign from Webpack that it was not able to load up the dependencies as you expected. You said, only get one copy, but also get a copy of version 5 and a copy of version 4 conflict. conflicting rules. And that gets manifested with a warning message like this. So whenever you see a warning message like this, it means that you have different sub projects that are trying to make use of different versions, but you also said only load one copy. So this message would be assigned to you that you would have to go do some debugging and figure out, ok, do we really only want to have one version or one copy? If you really only want 1 copy, can you increment 1 version, or can you decrement the other version to make these things compatible? So again, this is the assigned to you that you need to do a little bit more digging and figure out how to make these two separate projects compatible Adding on that Singleton flag doesn't change anything about running these projects in isolation. Everything still works as expected. It's only once we start to load up these different subapplications together, then we start to see this warning message. Okay, so I just wanted to show you that error message, just so you understand what happens when we try to load up one copy, but also multiple copies. So now we're going to undo that change we just made. So I'm going to revert this back to you in just Baker inside of products, revert it back to being just Baker inside of cart. And then once again, restart my weback processes. There's cart And here's products. They are using different versions right now. So if I go and refresh, I will no longer see a warning, but I will be loading up two copies of Baker once again OK, so again, just want to give you that information. Let's take a pause right here, and we're going to move on to one last really big topic around this project There's

### Sub-App Execution Context

* one last major thing I want to cover around our project. It's gonna involve a little bit of a refactor to all three different projects.Three different projects. So remember, a major, absolute requirement of microfronted applications is that we should be able to develop each subroject in isolation. And we should be able to run each project in the context of the container. And one thing to recall around this entire process is that, depending upon whether we are running products or cart in isolation versus a container, we're going to be executing our projects with a different html document. So if we have products in isolation, we're going to use the products html file. That's only during isolated development If we were ever developing the container or running the container in production, then our products application is going to be using the containers html file. So it turns out that there's some really interesting concerns around this. Let's go back over to our code editor inside of here. I'm going to find my product's source bootstrap.js file. O inside of here, I just want to point out that we have some code that is going to attemt to generate some html, and then always and instantly try to show that html inside of some very particular dom element. Now, right now we are making a very big assumption. We are assuming that there is some element inside of our html document with an ID of dev dash products We can make that assumption about our products html file, because the team who is working on the sub project has total control over this file, and they can make this id right here anything they want it to be. However, the product's team is not the container team. The container team is a separate engineering team in theory. And the container team might decide to have an html file that does not have a division inside of here with an id of dev dash products. They might have instead, some kind of id of products, or about my dash products. Let's do that. But my dash products here. So the products team cannot really control the structure of the container html file They can't 100 percent insure or guaranteed that some did exist, or some element, I should say, with an idea of dev dash products. So the code that we have inside of our products bootstrap .js file specifically, that segment right there is not too great. It's not very good because it assumes that some element exists when the element might not exist at all. And our products team can't really guarantee that that element will exist. With that in mind, we're going to refactor this bootstrap .js file and better take into account the fact that this element might not exist at all So I want to first begin by writing out a couple of comments, just to help you understand the refactor we're going to do. We're going to make two major changes, or really three and a half, or two and a half, maybe major changes to this file. O, the first comment I'm going to put in here, I want to think about 1 way in which we are going to execute this bootstrap dot js file. The 1st way I might call this like context or situation or whatever. Number one, that we're going to execute this file in is when we are Running this file in development in isolation So in that scenario, we are using our local indexhtml file Which Has an element with an id of dev dash products? So in this context, or this scenario right here, situation number one, we probably want to Immediately render our app into that element. There's no reason to delay. We're actively developing this project. We want to see this html appear on the screen because we're actively developing it and trying to tweak how this application works So that is context or situation number one. So let's now think about situation number two. So contacts are situation number two, whatever you want to call it. In this scenario We are running this file in development Or production Through the container app And there is no guarantee that Element with an id of dev products exists. So in this scenario, we do not want to Try to immediately render the app. You don't want to do that, because that element that we're looking for might not exist. And if we try to render something into an element that doesn't exist, we're just going to end up with an error message very quickly. So if I could get this, only if immediately good enough So we need to write out some code to handle both of these different situations. We need something to handle context or situation number 1 and something for situation number two. So let's kind of think about how we can write out some code to meet or match both these situations and let's write out some implementation for these in the next video.

### Refactoring Products

* Let's write out some code to satisfy a situation number one and number two. To get started, we're going to refactor some of the code at the top of this file first. I'm going to define A new function that I'm going to call mount. There's nothing special about the name Mount whatsoever. It is just an arbitrarily decided pawn name. The goal of the malfunction is to take in a reference to an html element. So we're going to receive some argument right here that referred to as L. So again, this is an html element. Then inside the mount function, we're going to do everything required to start up our app and then eventually produce some html and render it or display it inside of that element right there. So to make that happen inside of our case, I'm going to take everything from products down to about line 10 right there. I'm going to cut all that. And paste it inside of Mount Then, rather than rendering our application into this element that we're trying to find on the family, we're going to instead render our application into that element right there. We'll do linerhtml, like so So now we've got a function that we can call in either situation number one or number two. And just, you know, the approach of using this not function right here can be used with many other frameworks as well. For example, if you're making use of, say, react, rather than doing this last line right here, we could do something like, say, react Dom dot render and maybe some kind of app. We want to render it into that element that is being provided. So the idea of some function like this is going to ultimately work with many different frameworks. We might decide to use. Now, how are we going to use this with situation number one and situation number two? Well, in situation number two, there's something I want to point out here. Remember, we don't have any guarantee that we some element exists on the screen or inside of our html page that we can definitely render into. In addition, we probably do not want to try to immediately render the app. If we are showing our container, it's really up to the container to decide how, when and where our products application should be displayed on the screen. The container might only want to display our list of products if the user goes to some very particular url or if they click on some button. So in context for situation number two, rather than trying to call the malfunction immediately or anything like that, we are going to instead export the malfunction. By exporting the malfunction. Now our container can import the amount function and make use of it whenever it wants to. So now it's up to the container to decide when to show our products application on the screen. Now we do have to go over to the container and make sure we now import the mount function, eventually call it. But before we do, let's go ahead and take care of context or situation number one.
* Situation in which we are running this application in isolation. The first thing you have to do in this case is decide whether or not we are in isolation. For that, there are two checks that we're going to implement. The 1st check we're going to make is ensure that we are running this project in development mode. So for that, we're going to add in an if statement, and we're going to say if process. emv node under. node underscore emd is equal to development This is an environment variable that gets set automatically by Webpack. That environment variable gets set because inside of our webpack, config .js file, we had added in a mode of development. So because we put in that option right there, webpack is going to automatically replace this with development So if we are running our application in development mode, well, we're going to go into this if statement Then, once we are inside of here, we need to do one further check. Remember, we can be in situation number 2 and still be in development mode. O, in other words, If we are running our roducts application through our container in development mode, we're still going to satisfy this check. Now we need a second check inside of here to decide whether or not we are running products in isolation. This check is a little bit harder to implement because, well, how do you decide whether or not you're running products by itself? One very easy way we can do this is just put in some kind of very unique html element into the product's html document. And that's why we put in this div right here with an id of dev dash products. The. thought here is that only our products html file is going to have a div with that id. So if there's some element inside of our html document with that id right there, we're just going to assume that we are running products in isolation. In other words, we are assuming this html file has that element, and we are assuming that our public html file does not. Now that's not a very great assumption, because, of course, our container, or the engineering team and charge the container, they can very easily decide that they want to have some kind of element inside of you with an I. V of dev dash products. So it's not a great assumption, but I'm sure you can probably think of some way to make a very unique identifier that is probably. not going to show up inside the container app anytime soon, so you can change this to from save dev dash products to dev dash products, dev dash only or something like that. Something to just guarantee that we're only going to have an element like this inside of our products HTML file and probably never inside of our container Ok so I'm going to stick with dev dash products. So inside this if statement, I'm going to do AL document Very selector for Allendev products. And I'll say, if we found an element, then let's call our math function and provide that element. Try to render our a into it. So I'm going to put inside of here Or right above just to comment and say assuming our container doesn't have an element with ID dev products. So it's again a really big assumption, but honestly well, we're probably not have an ID like that in cyber container. So if we get into this if statement right here, that means we are probably. Running in isolation. So just running products by itself, and we're not executing products through our container A Ok, so we are ready to test out products by itself in isolation and make sure that our application still appears on the screen. Let's try that really quickly at my browser. I'll go to local host 8081 And yep, looks like our app still appears. So now we just need to make a quick change to our container app. We need to make sure that the container now tries to import this map function and eventually calls that mount function with wherever the container wants to show the product list on the screen. Let's take care of that refactor in the next video

### Consuming Remote Modules

* Application is now exporting this mound function. It's now inside of our container, inside the container's bootstrap dot js file. We need to make sure that we import the mount function and then eventually call it. So inside of the container source bootstrap dot js, we're going to update the products import statement to be Really braces mount from products index. So now that we've got this malfunction, we can choose to call it at any point in time that we want and we can display our product list app at anywhere on the screen. So we could only decide to show the product list when the user is at some particular URL or maybe when user clicks on a button or any other kind of scenario. Right now? Well, we're not really in kind of any of those kind of scenarios. We really just want to show the product list no matter what. So we are going to immediately call mount and we're going to make sure that we provide a reference to some html element that exists inside of the container, so that our product list knows where to display itself So inside of our container, index html file. Remember, I changed that id right there just a moment ago to my products. O, I'm going to do a selector and get elements And pass it off to the malfunction. Like so. Now, before we test this out, there's one little gotcha inside of here remember we are trying to import products slash products index So that is going to map up to our containers, web pack config file. We asked for something from the products module. So that's going to cause our webpack module federation plugin to go and try to load up that remote entry file. That's going to take us into our products, webpack config file. Inside of here, we had said, if anyone tries to import the products index, then instead, get them the index file. Now, just 1 little issue, our index dot js file is not what is actually exporting that mount function. It's actually Bootstrap js file so now. inside of our products webpack config file rather than giving someone source index if they ask for roducts index we actually want to give them the bootstrap File instead, which does export the malfunction. Just a little gotcha there OK, so I'm going to make that change and save this. You then need to very quickly restart our products application because we just made a change to its weback and ig file. But here's products. I'm just going to restart it very quickly. And now I think we are already for a test. So back inside my browser, I should be able to go to local host 8081 and still confirm that everything works as expected. Yet looks good. And I should be able to go to localist 8080 refresh the page and still see my product list appear on the screen. Awesome. Okay. So the pattern that we now have here, specifically inside of our products, bootstrap dot js file. This is how we are going to export stuff from our application in Java. We're going to have some kind of a central point inside of our project that's going to define a malfunction. The malfunction is going to be the true start up location of our project. If we call mount, then we're going to create our react application, or our angular app, or our view app, or whatever else we're going to try to render our application into that element. Then Laura down the file. We're going to have these different sets of checks. We're going to see if we are running this project in isolation. If we are, we're going to attemt to render our app right away into some element that probably only exists inside of our local projects html file. Otherwise, if we are trying to run our project through some other kind of means, in other words, through our container, we're just going to rely upon the exports, just to know the export always happens no matter what, whether we are in development or whatever. But this just means we're going to make use of this export statement. So it looks good. Let's take a quick pause right here. We're going to repeat this exact same process for our cart application as well. They'll be really quick, since we Now know exactly what we need to do

### Refactoring Cart

* All right, let's repeat these exact same refactor inside of our cart application. So to get started, I'm going to find my cart. I'm going to find the src directory for bootstrap.js. At the top right, underneath our import statement, i'll add in constant mount We're going to receive some kind of html element as an argument. I'll then cut and paste everything down there into the malfunction. And then rather try it than trying to render our application into some carpet dev element. We're going to instead render it into that provided element Then after that, we'll put in a check to see if we are running this project in development and in isolation. We'll do a process emv node envy Of development Then AL will try to find some element inside of our local html file with an idea of dev dash cart. And what I think we actually call this one cart dev. Yeah, her dash dev. This one is actually hurt death. So then, if that element does exist, let's call them out After that, we will export our mount function. And that should be it. So again, the expert is going to be used by our container application Before we go over to our container, we do it About to update our webpack config file. So we need to make sure that anytime someone tries to get at carp show, we're not going to give them the index js file. Instead, we're going to give them our bootstrap js file. So bootstrap After saving that webpack file, we'll then go and restart our webpack process for the cart very quickly. Once again It's a background my terminal here's my internal window that is running my cart. I'll restart webpack. And then back inside of our container I'm gonna first go into the container's index dot html file. I'm gonna make sure that this html file does not have a cart dev element anymore. I'll change this to my cart because remember, if it does have a dev dash card or cart dev whatever it was, then the cart is going to try to render itself immediately. And we don't want that. We want the container to control when the cart renders. Then finally inside of our container src bootstrap file. We can import mount from card show Call Mount. The document. For your selector my. kernel And that should be it We're going to see this Go back over to my browser I'll do a refresh. Duplicate variable names here. Steak, a little change we need to make. We've got two functions called mount now. All we need to do is just rename one of them, or both them on the family. So I'm going to rename the Roducts Index Mount as. Products mount like so and as cart. Note then the first one will be products mount instead. All we're doing is renaming that import so that they are not colliding. And cartnotes much better. Ok. So now, if we test, once again, we see our application appear. And I should also be able to go to local host 8082 and see my cart in isolation as well. Erfect. So now we can develop all these different applications in isolation if we want. Here is localist 8082. Here's 8081 which is products. And here is the container, which is loading up both applications. So that's saying this looks pretty good. All right. Well, that's pretty much it for this first application. But there's still a lot for us to learn about microfront ends. So let's take a pause right here. Going to do a wrap up on this application and continue on to our next one in just a little bit.

### [Optional] A Funny Gotcha

* This is an optional video. I just want to show you a little bit of behind the seed stuff around the module federation plugin in particular. Only show you one bug that's a total gotcha, so if you are not interested, if you just want to move on to the next application, pause this video right now and continue on. Otherwise, stick around. So I'm going to first get started inside of my cart webpack config .Js file. You may recall that we briefly discussed this main property right here, which we have listed as cart. And when we discussed it, I told you that this cart right here has to match up with our container web pack and fake file. specifically cart at that part of that string right there. The cart right here has to match up with cart right there. I just want to tell you a little bit more about why that is and go into one very small bug that you might run into that's really, really challenging to troubleshoot. Okay, so 1st off, back inside my browser, I'm going to go to local host 8080. And once here, I'm going to again open up my network request tab, and I'm going to take a look at the remote entry file that is coming in from local host 8082 which is, you'll recall our cart application. So you're. local host 8082 remote entry.js. I'm going to click on that. And if I take a look at either preview or response, I want you to notice something here on around line 9 or so. You'll notice it says bar cart So it declares a variable, and then it assigns a value to that variable. And a value it assigns is basically the result of all of this web packed stuff. So the issue here is, what is this var cart thing? Well, it turns out that when web pack inside the browser loads up this remote entry dot js file, it needs some way of accessing the code inside of remote entry. It needs some way of reaching in there and saying, aha, this is the code or the configuration that I'm being provided This cart variable is how that communication is done. Whenever our browser or webpack running inside the browser loads up that remote entry file, it's going to look for a cart variable inside there, and it's going to try to access that variable to get all the information contained inside of this remote entry file. So this current variable is really being kind of accessed and set on both sides of the equation. First off, whenever our container webpack dot config file, whenever our container is trying to access that remote entry file, it's going to try to look inside there for a variable called cart And that variable name is set by that value right there. If we change that car right there to anything else, like let's say about my cart, and then say this, and then restart our container web pack process I'm going to restart the container very quickly here If I then go back over to my browser and refresh the application, we're going to very quickly see an error. You'll notice inside of here, we're seeing some errors. Load script failure, blah, blah, blah, all this stuff, because now our container app, which is running inside the browser, is trying to look inside that remote entry file and find a variable called my cart instead of just cart. But the remote entry file that is being served up from our cart application still has a variable inside there of cart. So if you wanted to fix this, we could obviously revert the change we just made. Or alternately, we could go into our car project, find the web pack config inside there, and then change that name to my. cart as well So now if I say this and also restart my cart application We're going to restart cart Now both sides of the equation are kind of matched up, so to speak. The container is looking for a variable called my cart, and the cart is providing a variable called my cart. So now if I refresh this, everything works as expected. And now inside that remote boat entry file, I can once again see my cart. Now, I mentioned a bug around all this stuff. Where's the bug? What's the kind of issue here? Well, let's make a very small change. First off, I'm gonna revert the 2 my current things really quickly. Go inside of cart web pack and big. I'll change the name back to cart and save the file And back inside of a container webpack config. I'm going to find that string right there, change my cart, back to cart as well. And then I'll restart once again. Both those wet pack processes. So yours container And here's cart. I'm going to very quickly just verify everything is still working as expected. Ok, so where's the bug? Well, let's go back and retort editor inside of my container. I'm going to open up the index.html file, and you'll recall that we put in a div right here with an id of my cart. I need it very quickly. Just change that to cart by itself. Very important that we put just cart. We're going to save that file. I'm also going to go to my bootstrap dot js file. We'll recall that is where we are trying to select that element. And I'll just update that selector to pound cart, just to say, hey, look, we're trying to select the correct element. So in theory, everything should work just fine. All we did was change the id of an element, but we did. go and update the selector as well. So I honestly would fully expect everything to continue working as expected. But as you guess, well, it doesn't. If we pull it back over to local host 8080 we now get a nasty error message. Fn is not a function. So what in the world is going on here? Why would changing an id on an html element somehow break our application? Well, the answer is pretty straightforward. First, I'm going to undo that id change very quickly They'll undo the change in bootstrap and inside of index html. So I'm back to in theory, everything working So everything works again in the browser. Now, inside my console I'm going to try to print out the cart variable. This cart variable is being created by our remote entry file coming from our cart application. Let's see remote entry file we were just looking at. This right here is being declared as a global variable, so we can very easily print it out at our console. If we print it out and then open this thing up, you'll see that it's an object that has a git function and a knit function. This is essentially how we interface with a code coming from that remote entry file of the cart alication. So essentially we have an object here that allows us to get access to all the code, or looking to load into our container. So now that we've established that there's a very global variable called cart, let's now go back. And change that id once again. So I'm going to go back to just cart. I'll change it inside of bootstrap js as well. Save both those files. Now here's the error message again. And now this time, let's print out cart again and see what happens. Now, when we try to print out that global variable, we instead get a reference to that div. So here is the bug, the big bug. I shouldn't even say bug per se, but something is just really, really misleading. If you ever assign an id to an element, your browser is going to try to create a new global variable with its. same exact name as that id. So because we gave this division id of cart, your browser is going to try to create a global variable called cart. That global variable is going to overwrite The Kurt Global variable that gets defined inside of this remote entry file. I'm not looking at products, but you get the same idea. It's going to try to overwrite the global variable that is defined inside of our cart remote entry file. So eventually, when web pack inside the browser tries to access cart instead of getting our code coming from the cart application, it instead gets an html element. And that's why we end up with this air right here. F. N. Is not a function. No, that's a pretty weird body. You kind of have to connect the dots here, understand that the id is going to be assigned as a global variable. And you also have to understand that the remote entry file coming from our current application is going to try to declare a global variable as well. And the two are going to complain. So to fix this, all we have to do is make sure that we don't have some element inside of our dom with an id equal to whatever is coming across inside of that remote entry file. Another. words, we don't want to have an I. D. With the same name as that thing right there. Now that might sound like not that great. A very common class name that you might see in a lot of different projects is about car. That's a very common last name. So if you ever have a sub project that is named card, you might want to put a name of card right here. And then if you end up with, say, rather than a class name, an id of car on some html element, well, all sudden, everything is going to break. Don't worry, we're going to fix this whole situation up in a little bit and ensure that we probably have some module names that are not going to conflict with any elements that we are rendering or trying to create inside of our html document Okay, so I apologize for the length of this video. I just thought this was a very interesting little bug to run into. So really quickly, I'm going to go back to my bootstrap js file inside of container. I'm going to restore the idea of my cart right there. And inside of my html document, i'll change that back to my card as well. And now, if I load up inside the browser, once again, everything works as expected. OK, so let's pause right here and move on to our next application in just a moment.

## Linking Multiple Apps Together

### Application Overview

* But there's still a tremendous amount for us to learn. For example, we need to handle, say, navigation. We need to be able to work with multiple different frameworks, such as react or view and so on. We need to also think very deeply about stuff like deployment as well. So in this video, we're going to start to kick off our next application, which is going to be way, way more complex than the one we've just put together. Let's 1st begin by taking a look at a couple of mockups of what we're going to try to build Okay, so we're going to imagine that we're building a kind of startup or kind of software as a service application. So we're going to be building a landing page. We're going to be building stuff like some authentication, and then eventually some kind of internal feature that a user can only get to after they sign up. Now I want to be extremely clear from the get go right now. This application doesn't actually do anything. There's no actual database. There's no actual remote server or api. There's no real authentication system just about all the elements that you're going to see here in these different lockups are going to be like dummy elements. The user can click on them and obviously see them, but they're not really going to do anything per se or present any real data. We are much more interested in just how we make use of all these different frameworks, how we wire them together and stuff like that. That's what we are focused on for this application. OK, so the first thing that we're going to put together for a user to see is a landing page of source. So a user is going to come to our application at say com and they'll see some kind of marketing landing page where we will tell them, hey, welcome, come and take a look at our pricing and eventually sign up for our application. If a user clicks on this C pricing button, we'll then take them to a pricing age. Her user can take a look at all the different prices that we offer. Now, again, there is no actual payments or anything like that. This is all just absolutely fake data. But the point is, there's going to be some kind of pricing page a user can go to. I'll show this to a user whenever they go to slash pricing. Eventually, in theory, a user is going to either try to sign up, or maybe they're going to try to log in using that button inside the header. So whenever user signs up or logs in, we're going to take them to some kind of authentication page. So a page to sign in. Or alternatively, sign up. Then whenever a user clicks on this sign in or sign a button, we're then going to take them to the primary feature of our application, which is going to be some kind of admin dashboard of source. So on this page, we're going to eventually show a bunch of different pretty charts and tables and stuff like that again. All the data is going to be 100 percent fake. Not going to interact with it in any way, but we're going to show some just pretty stuff to our users and what not. Okay, so that's we're going to be building. And the first thing I want to think about is what we might call each of these different pages. I want to think about what the goal of each page is and just assign a name to them so that you and I can easily refer to them in the future. So as I start to look at these different pages, I think it's pretty easy to come up with some different names for each of them. First off, this main landing page, we could call it, say, landing page or home page. Either one works totally fine. We definitely have some kind of pricing page right here. This could also be a plans page, or something like that, either one's totally fine We then have a sign in and a sign up. And then finally, some kind of dashboard page over here Obviously names to each of these things. I want you to start to think about how you would group each of these different pages together in terms of functionality and what they do and their overall goal and purpose. So out of these five different pages, how might you root these together if you have to say, hey, this page is really similar to this page? Well, I think that a pretty obvious way to go about this might be something like this right here. I think the home page and the pricing page are really about marketing or kind of users sign up or stuff like that, trying to get people to sign up to our application. The actual sign in and sign up pages are really all about authentication. And those are purely very friendly couple pages. They really do just about the same exact thing. And then finally, this dashboard page down here is really, it's kind of own standalone thing. We could call that easily dashboard, or maybe if we knew exactly what kind of data we were showing, we can think of a better name for it than just dashboard. But I think right now just a overall category of culling a dashboard will work just fine. So overall, I think that we have five different pages. And I think that we have three distinct different areas of functionality. So we might decide to create three different engineering teams. Maybe one team will be in charge of the marketing aspects of our product. Maybe another will be in charge of medication and then another in charge of the actual dashboard or real functionality of our product. Now when I say that, you might say, Steven, we don't need a whole team of Engineers in charge of just authentication. Okay, fully understand. Nonetheless, we're just going to pretend that we need a full team of Engineers to knockout this whole authentication piece. OK, so at this point I think that we've laid out the overall project. You have an understanding that we're going to be building 5 different pages and I think that there's kind of three distinct areas of functionality inside of our product that we need to think about and we might want to have a dedicated team to each of those three distinct areas. So with this in mind, let's do just a little bit more planning in the next video.

### Tech Stack

* We've now established that we're going to have three major areas of our application, marketing, authentication and the dashboard. So we're going to create three different microfront ends, 1 for marketing, 1 for authentication and one for dashboard. In addition to these three different micro front ends, we're still going to have a container application that is going to coordinate these together and decide which microfront end to show on the screen at any given time. For each of these, rather than writing them out with plain javascript code, as we did on our first application, we're going to instead use some front end frameworks. So here are the different frameworks you're going to use for the container, marketing and authentication. We're going to be making use of react. And for the dashboard, we're going to make use of view. And as soon as I show you this, you might say, Hey, Steven, wait a minute. I want to use angular, or I want to use helt or web components or something else. I got to be a totally honest with you. We are going to spend not a lot of time trying to understand how to get microfriend frameworks to work with these different front end libraries, like react or view instead. We're going to focus on understanding how to create different integration techniques where we don't have to worry about the implementation details of react or view or web components or anything like that. That's the real goal here. We want to create microprint apps that can be substituted in for each other without having to worry about having some really precise coordination between, say, the container and authentication. In other words, when we try to show authentication inside the container, even though they are both react applications, we're not going to show authentication as a plain component inside of container instead. We're going to have a very generic coupling method, which guarantees that we could eventually substitute out this react version of authentication with some other framework in the future, like maybe we want to convert it to be view or angular, or whatever else, and we would want to make sure that we can do that conversion without having to do a major rewrite of the container or anything like that. So again, we're going to focus on having very generic interface points. OK, so now we understand that I just want to give you one more very brief discussion in the next video and justice layout some really big requirements of our project and really understand what we are trying to accomplish here.

### Requirements That Drive Architecture Choice

* It was going to be a little bit long, so I apologize in advance, but it is a very important video. Let me tell you why. OK, so as we start to build out this application, we're going to make some very distinct architectural decisions. And some of the code and techniques I'm going to show you are going to be a little bit different than what's in different blog posts, articles and so on out there are going to tell you to do when it comes to microfinance. Now, that's not to say that I'm telling you to do stuff that is just wildly different than accepted practices. Instead, the real situation here, the reality of what's going on around microfundance, is that there is a wide spectrum or a wide variety of different techniques you can use. And some blog posts and some articles are going to be just in direct disagreement with what the best practices are. So for this application, I sat down and said, here are the hard requirements. Here is how this application must behave. And I used those requirements to come up with a set of architectural decisions. So in this video, I'm going to tell you about some of the requirements of our app, and you're going to very quickly understand how those requirements are driving the exact technique of how we are putting everything together. The only thing I want to do just to be really clear here is tell you exactly what some techniques are that we're going to do versus what some other people are going to say. So some things you might see and some different blog posts and what not, you might see stuff that says, Oh yeah, you should always share state between applications using Redux. You might see stuff that says the container app must be built with web components and some other. stuff like that. Now, none of these things are necessarily wrong or say they just have different sets of requirements than what are requirements are. Once I show you all requirements, I think you're going to agree that we have a very reasonable set of requirements that very closely mesh with the overall goals of microfronts. So even though some people will be in a little bit disagreement with some of the techniques we're using, I personally think this is a very solid foundation, very solid architecture that we're going to build out here. Okay. So here are our requirements. So we've got about five of them. And each of them, I've labeled as being inflexible. So that means we must, under all scenarios, satisfy these requirements. And again, these different requirements going to drive our overall architecture. So our first big requirement is that we must have 0 coupling between child projects. So that means that we cannot do any imports of, say, functions, objects, classes, anything between our different child projects. We can't have any shared state no redox stores, no reducers, no contacts, nothing like that can be shared between child projects. The one exception are shared libraries through the module federation system. And the reason for that is that it's absolutely okay if you share a library, because if some other project falls away or decides not to use that library anymore, our first project that might use that library is still going to get access to it through the module federation system So why is this? Why do we have this requirement at all? Well, let me layout a real quick scenario for you here. So let's imagine you've got our container marketing and authentication and maybe marketing and authentication are both built using react. Now let's imagine for justice a moment that we build these two subrojects with a very high degree of coupling. Maybe they both make use of Redux and they try to share the same store. Maybe they expect to receive actions from each other. Maybe they try to show react components or whatever it is. At the end of the day, let's imagine we have very tight coupling between these two projects. Now let's kind of think forward like 5 or 10 years. Let's say that in five or 10 years we are still working on the same overall project and maybe in five or 10 years we decide that instead of using react for marketing, maybe we decide to completely rewrite our marketing project and we're going to use some brand new framework that just came out called Lover for some reason. Maybe it's really great for marketing stuff Well, in five or 10 years, if we decide to go and replace marketing, that would kind of apply that we would have to make some serious updates to our authentication system as well. Because like I just said, there's very tight coupling between these two projects. Maybe authentication just doesn't work correctly unless marketing is loaded up inside the browser group. So if we have any coupling like that and we try to change marketing, we might be easily breaking 100 percent our authentication application. So the less we couple these things together, the less we have to worry about making changes to one project and breaking another by mistake Now this entire requirement might not make a ton of sense. You might say, hey, Steven, surely we can share react compliance or something like that. We can always just like copy paste those shared components from marketing over to authentication. Well, if you've never worked at a large company where you are working on software systems that were written many years ago, let me tell you, I very much have and something that you really need to understand if you have not been in that scenario is that at some point in time we are all going to forget how react works at some point in time and some number of years react is going to be an old ancient framework that nobody knows how to use or nobody maybe nobody wants to use in general. So less that or the more that you can isolate your different applications, the better off you're going to be in some number of years because it means that you're going to be able to replace or make updates to different part of your application without worrying about breaking some other part that you might not want to touch at all or might not even know how to touch. You might not know how to even start up or react project in five or 10 years. And trust me, that is entirely possible. OK. So that is hard requirement number 10 coupling, just none. No sharing of anything whatsoever. So hard requirement number two. Here we go. We're gonna have almost zero coupling between our container and child applications. So our container is gonna be able to have some amount of communication with the child app. Having said that, the container will not assume that the child is using any particular framework. So even though we're starting off with container using react and two of our sub projects using react, we're not gonna communicate between them in any necessarily react specific way. Instead, we're gonna try to make that interface as generic as possible. Any communication that we do have to do is not gonna use any fancy framework like redox or anything like that. Instead, we're gonna use very simple and basic systems like callbacks or very simple event structures. That's it. That means that we can have some communication. Between our container and let's say the marketing application Oregon, the authentication application, these two things can communicate just fine, but we don't want to have communication between marketing and authentication. So why the divide here? Well, it really comes down to just practicality at some point in time. The authentication system for our application absolutely just does have to communicate up to the container in subway. Let me tell you why that is. If we think back to our mock up over here Here's our sign in and sign up. We've got a header on every single page. This header is going to be rendered by our container. Eventually, a user is going to sign in, and whenever they do, we're going to want to put that login button right there to say, log out instead. So we need to make sure that whenever user successfully logs in through this sign in system or the authentication system, we need to somehow tell the container that the user is now considered to be authenticated and that we should change the text of that button. So we are going to allow some level of communication between a child app and the parent. We technically can have ways where we even avoid this level of communication. And I'll tell you what those are. But we're going to say that we kind of assume, yeah, we need to have at least a tiny bit of communication between the child and the parent
* Okay Requirement number three Css from one project should never affect another. What this really means is that all of our styling, all of our C should be 100% scoped. So any styling that we add to say the marketing page should never, under any scenario, affect something on, say, the dashboard. The reason for this is very simple. If we start changing the css on the marketing page, I don't want to just magically find out a week later that we accidentally broke the display of the dashboard at some point in time. This goes back to the entire same idea of making changes to 1 project shouldn't break another very. so very simple. We don't want to have any css and a shared or accidentally affecting some other part of our app. We're going to have to figure out some techniques and styles to scope all of our css. 8 number 4 So it's number 4. We are going to eventually make use of version control as we start to deploy our application. I don't want our style of version control to have any impact on how we develop our project or how we deploy it, or anything like that. Obviously, if we use, say, a mono repo, we're going to have all of our projects inside of a single repository versus separate repositories for each individual project. Obviously, we are going to have some level of difference between the two. It kind of comes down to having to do a single git checkout versus, say, 10 get checkouts. But beyond that, I don't want to have a major impact on how we develop our project, how we deploy it, or anything like that. Some. people out there want to use Monterey posts. If you do totally fine, other people want to have a separate reo for each individual project because they say, hey, these are microfront ends. They should be standalone. Either way, it should just plain, not make a difference. For our project, we are going to use a mono repo, but at the end of the day, if you want to use separate repos, everything will work 100 percent. Okay. If you want to do so, it just requires a lot of additional setup because you now have to create four separate repositories on Github, which is what we're going to use as opposed to 1 repository. Okay, very last thing. This one is a little bit challenging to understand, but we're going to spend a lot of time to really understand this requirement and why it exists at all. This really comes down to the production deployment of our project. So that's where this requirement is really going to come into play. So our container should have the ability to decide to use either the latest version of a microphone end or a specific version of a microplanet. So in the words, at some point in time, you and I are going to say, make some changes to marketing. We might eventually deploy it and then realize, oh, we need to add in some new section or something like that. We'll make some changes and redeploy the project every. time every time we do a deploy, we're kind of creating a different version of our marketing project. And I want to allow our container to decide either to always use a very specific version of marketing, or just use the latest version. Now, whether you would decide to use one or another really comes down to your requirements of a as a company. Some companies say, I want to be able to pin my version of something like marketing and always use that same version and only do updates at very specific points in time. That's pretty much where this requirement is coming from. That's our last big requirement. And again, we're only going to really see this start to come up as we start to think about deployment and some stuff like that. Okay, so that is it. I apologize again for the long video, but again, these requirements are 100 percent driving. our architecture choices along every single step of the way. We're going to follow each of these requirements as best as we can. The only exception is for requirements number two right here The requirement number two, we're going to bend this one just a little bit when it comes to handling navigation. And I'll tell you exactly how we're bending this rule to be very obvious. I'm going to very clearly outline it, but I'm going to tell you how we can not bend it if you want to make sure that you have true separation between the container and the child applications. Okay, so that's it. Let's pause right here and get started on our application in the next video. No

### Dependency Installation

* Last video you should have found a zip file attached to a lecture called something like mfp zin. Inside of here is a collection of different package dot JSON files, each of them list outs in the different dependencies that we're going to need for each of our different sub projects. We're going to extract the zip file, thus going to create a new folder called MFP. Inside We're going to find once again each of these different project directories with the package Json file inside them. So we're going to open up our journal and go into each of these different project folders and run in team install to get all the different listed dependencies. So add my terminal I'll change into this mfp folder. Inside there is a directory called packages called change into there. And then, once again, we're going to go into each of these different directories and do an npm install. So I will first go into off And there we go All right. So we're going to take a pause right here. I'm going to let you go through the three other sub projects and run and keep install inside of each of them. After you do that, we'll come back to the next video and go through a little bit more setup.

### Initial Webpack Config

* Let's now move on to our development webpack file. So webpack.Dev.js inside of here, we're going to first require in something called merge from a library named webpack merge. Merge is a function that we can use to merge together two different webpack and big objects. So this merge function is what's going to allow us to take all the config that we just wrote out inside that common file. Entity rational poren you have the Vermont and November satisfaction integrated. General important. State manipulator. And merge it together with the configuration that we're about to write inside this development file. That's all the merge function does. After that, we'll then get a very familiar plugin called the html webpack plugin Remember, this is what is going to take Some kind of html file inside of our project and inject a couple of different script tags inside of it. After that, we'll then define our configuration So I'm going to say debt can big. Notice that we are not assigning anything to module experts here just yet. Inside this object, we'll set UA mode property of development. Assign a dev server. That's going to have a port of 8081. We're also going to give this thing an additional option, this time called history api fall back. Do double check your capitalization. Make sure you've got capital a lower case P and I and a capital F. I will give it a index property of indexhtml. We're going to come back and understand what this property does in a little bit. Once you start to talk about navigation inside wrap Then, after the dev server section, we'll put in plugin's that's going to be an array as well. And justice, as we did before, we're going to add in the new html weback lugin, give it an object with a template property Of SRC, excuse me, we want public Index html. That's better Ok, so this is our development specific configuration. This is configuration we only want to provide to webpack when we are running it inside of a development mode. So now we need to take our dev config and merge it together with a configuration that we wrote out inside the common file. To do so, we're going to require in the common configuration at the top. We'll say, constant config is required. Dot slash webpack .com And then at the very bottom of this file. We're going to do our typical module dot exports, and we will assign it Result of merging together are common config and the dev config By listing out the depth config second, that means that the depth config is going to override or kind of take priority over any other similar options we might have assigned to a common config. Ok so that should be it for our initial webpack setup. We've now got everything running, hopefully inside of a development environment. Now the last thing we need to do is create some kind of starter index dot js file and a starter html file as well. So let's take care of some initial code setup in the next video Inside of our marketing directory, we're going to create two new folders. One is going to be an src directory, and the other will be a public directory. These two folders are going to do the same thing they did on our last project. Src, Will contain all of our source code and public will contain an html file. So inside of marketing, I will make one new folder called public And then a new file inside there called index HTML. Inside that I'm going to immediately add in some very basic html elements. So a doctype we'll put in an HTML element Ahead And a body. And right now we will leave the body element empty. I'll then save that file and close it. Next up, once again inside the marketing directory. We'll make a new folder of src Inside that I'll make a new file of index js. And right now we'll just do a very simple console log of hi there. OK, so now all we have to do is add in a script to start up our project and I think we are ready to test everything out. So I'm going to open up my package .Json file inside the marketing directory I will find these scripts section. I'm going to delete the test script that is inside there And replace it with a script at all called start whenever. we run start, we're going to execute webpack serve just as we did on our last project. But we're also going to tell Webac which of our different config files it should use. So we're going to add in A dash config And then go into the config directory. So config slash and use the webpack.dev.js file as a source of all of our configuration. Ok, I'm going to save this. We'll then go back over to our terminal and try starting our project up. So at my turmoil, I'm at my mfp overall project directory. I'm going to first change into the packages folder, which is where all of our different sub projects live. We'll then change into marketing And try and npm start, or npm run start. Either one will work just fine. Ok looks pretty good, so I don't see any errors or anything like that. I do see what looks like a breaking change right here. That's totally fine. You might have some deprecation warning. Totally fine as long as you don't see a distinct red error message or totally okay. So now we can test out our applications by the browser. Remember, this app is running on port 8081 so we will open U our browser. And go to localhost colon 8081 Then once there, we should be able to open up our console and see, hi there appear. Perfect. Ok, so looks like we are off to a good start. Let's start to implement some actual, interesting stuff around our marketing app in the next video.

### Wiring Up React

* I think we're now ready to start doing some serious development on our marketing project before we start to write any code. However, I just want to give you a very quick reminder about something that happened on our E commerce project just a little bit ago. So I've got my code editor from the ecommerce project right here. You might recall that on our cart and products applications, we eventually tried to share a dependency called thinker. And you might remember that as soon as we started to share that dependency, we then started to get an error whenever we were loading up our different sub applications of products or cart in isolation That error was related to the fact that we were trying to make use of Baker before it had actually been loaded into the browser. To get around that error, we created two different files to start up our project. So inside of products and this happened in Kurt as well, we have created inside of our SRC directory in index .js file that would import in the bootstrap file. The only goal of index dot JS was to add in this import function. And all that did was give web pack inside the browser some time to load up Baker before it actually executed the bootstrap .js file. Because as soon as bootstrap gets executed We are going to try to immediately import Baker. And if we don't have access to faker, well, we're going to very quickly get an error message. So we're going to take the scene kind of pattern inside of all of our different subrojects inside of mfp as well. We're going to create an index .js file, which will immediately import something called simply bootstrap Ok so back inside of marketing, I'll find the src directory inside there. I'm going to make a new file called bootstrap .js. Then inside of index js, I'm going to remove the console log we just added, and I'm going to import dot slash bootstrap. OK that's it. We don't have to touch the index .js file again. Now inside of bootstrap is where we're going to add in our main startup code. Thinking back to our ecom project, or the E commerce project, once again, you might recall that in bootstrap, we had to find a mount function to. start up the app We are then defined two different cases to handle. We had said if we are in development And in isolation All mount immediately otherwise. and technically not otherwise, because we didn't really have an else case or anything like that. We would assume that we are running through container and we should export the Function so that the container can decide where to mount our marketing app. We're going to use this exact same approach on marketing as well, and dashboard and off for that matter Let's first get started by putting together a little bit of basic code, just what we need to get a very simple react application started. U
* Now, of course, you might not have any familiarity with react whatsoever if you don't. That's totally OK. I'm going to explain exactly what we're doing as we go through this. So at the very top of this file, we'll first import react from react We will import another library called react Dom from react Dom Then to define our malfunction. We'll define a function called Mount. And we're going to assume that this will be called with some kind of html element. Then you might recall, in our previous projects, we just generated some html and displayed it inside this element. Now that we are using react, that process is going to be slightly, slightly different. So to get our application to start up or to get some content to appear on the screen, we're going to instead call a function called react dom dot render We're going to call it I'm gonna split this into multiple lines, just to make it a little bit easier to read. And then as the first argument to it, I'm gonna put in what looks like html So it's going to be an H1 element that just says, hi there. I'll then put in a comma. And as the second argument, we'll put in where we want to render this html looking stuff too. So in this case, we're going to render it to the element that was passed into this function. It will provide L like 7. And that is it for our malfunction. Believe it or not, it is just that simple. Now we're going to add in our two other checks. They're going to look identical to the checks we had added in on our previous projects. So we first need to decide whether or not we are running this application in development And to that, we can take a look at process. Always get that auto complete process. Emb node underscore emv. And we're going to check to see if that is equal to the string development. If it is, then we're going to try to find some element inside of our html file that we're going to expect to only be present inside of our marketing html file. O, let's go add in some elements right away. And we're going to give this thing an id, or some kind of selector that's probably not going to be duplicated inside of our container app. So I'm going to add in a dip here with an id. And we'll give this thing an id of how about underscore beaddev root, very unlikely, not B, but marketing. Marketing dev route. So very unlikely That our container html file is ever going to have an id like that. Then back over inside a bootstrap js. We're going to try to select that element I'll call it debt root this time. Last time, I think we called it L. Doesn't really matter what we call it, and we're going to try to select that using a document. Selector. And our selector will be pound And then what we just wrote out over there, which was marketing dev route with the underscore at the start. Then, if we find that element, if it actually exists, we will call our mount function and pass in dev root like so Ok so that's it, then finally we'll handle the case in which we are running our application through a container. So in that case, we'll once again just do an export of Mount Ok so let's save this. Go back with the. And see how we are doing. To back inside the browser at local host 8081 I should see the content hi there appear on the screen, which means we are now successfully making use of react to dislay some content. O let's say this is a pretty good start. We've got our marketing application running react in isolation. So let's take a pause right here and start to add in some more interesting content on the screen in just a moment.

### Adding the Pricing and Landing Pages

* In the last lecture, you should have found a zip file called marketing components. Inside of here are the two react components that are marketing app needs to show. Specifically, the landing page and the pricing page. Let's extract the zip file inside there as a component's directory. We're going to take that components folder and drag and Drop it into the src folder of our marketing project. So I'll do a very simple drag and drop like so we're going to make sure we copy the folder, as opposed to adding it as a workspace. So now inside the src directory, I should see components and then landing and pricing. So why are we not writing out all these components from scratch? Well, it's very simple. Inside of each of them is really just essentially a lot of markup. If you open up either file, you're going to see a ton of JSX elements inside of here. Those essentially just a lot of styling stuff, stuff that's not really relevant for us to go through inside the context of this course. So rather than sitting down and spending probably about 20 minutes writing out the contents of these files, I just wanted to save a little bit of time and give you the contents directly. All right, now that we've got these violins inside of here, we need to actually wire them up to our project. So let's take a very quick pause right here and then wire them up to our marketing app in the next video
