# Microfrontends with React: A Complete Developer's Guide

## What is a Microfrontend

* Let's start to dive into the technical side of microfront. The first thing we're going to cover is exactly what a micro front end is. Obviously, a really important part of understanding what these things are all about and how to use them. So to really understand microfront ends, I first want to imagine that we are building some kind of ecommerce application like the 1 you see right here. So maybe our ecommerce application has two separate pages to it, a page to list out all the different products we have for sale. And then another page to show a shopping cart. Essentially all the items in the user intends to purchase. So in our application, we have these two separate pages. Let's imagine that we are building an application like this using a classic approach, where we have one single, single page application. We might build this using react or view or angular. And inside this project, we might have a lot of code around implementing some kind of product listing page and a lot of code to implement something around a shopping cart page. Because all the code for our entire application is in one single code base. You might refer to this as a monolithic, single page application. If. we wanted to turn this into a micro front end application, then we could take a look at our original knock ups and then try to identify each distinct and major feature inside of our app, go inside of our application. Here we really have two major distinct features. We've got the product listing page and the shopping cart page. After identifying each of these major features, we can then split each of them into their own separate code base. So we might have all the code for our product listing inside of one single page application using reactor. view angular or whatever else, or we might have all the code for our shopping cart inside of a totally separate application. Now, as soon as we start to split up these two different code bases, we start to run into a lot of interesting questions very quickly. For example, if a user clicks on this add to card button right here, we clearly have some kind of need to add this product to this cart listing page over here. Well, inside of a microfront end approach kind of application as much as possible, we try to prevent direct communication between these two distinct projects. Instead, to accomplish something like, say, adding a product to a cart, we would instead have our product listing application. maybe make some kind of request to an api that manages all the data inside the user's shopping cart. And then whenever a user loads up these shopping cart application to see their products that they've added to their cart, the shopping cart app would make a request that same api and get a listing of all the products that is in their cart. You'll notice that we do not have any kind of direct communication between these two smaller applications. Now, why would we use microfront X? What benefit do we get to splitting these things up into separate apps? Well, there's 1GIGANTIC very large benefit that we get, and that is that each of these applications can now be a thought of as separate, independent apps. There's no direct communication between them. There's no direct dependency between them. That means we could assign the development of product listing to, say, engineering team number one, who could just assign the development of this shopping cart app to a totally separate engineering team. These can be. two different engineering teams inside of our company and they could decide to make radically different technical decisions for implementing each of these projects. So for example, engineering team #1 could decide to build this project using react and maybe engineering team #2 could decide to implement this using angular or something else. Now of course, we probably want to limit the number of frameworks being used at our company, but the point here is that each engineering team can build their application with their own preferred development style whatever. works best for them. OK, so let's summarize what we've covered inside this video.
* It's a microfront ends are where we take a monolithic application and we divide it into multiple smaller applications. Each of these smaller applications are responsible for one distinct major feature of our product as much as possible. We try to prevent these different micro applications from communicating with each other directly We make use of microfront ends because it allows multiple different engineering teams to work on the same overall application, but in total isolation. O if engineering team a or number one, make some kind of breaking change to their A It's not going to necessarily break some other part of our application. In addition, when we start to divide our application out into microfront ends, it makes each of these smaller parts a lot easier to understand and make changes to without accidentally breaking some other part of our app as well. Ok, so good intro. Let's take a pause right here and go a little bit deeper in the next video.

## Application Overview

* Let's take a look at the first application we're going to build to get a better idea of how microfriends work Here's a little mock up. We're gonna make a very simple, very straightforward application that's going to use just about no frameworks inside of it. We're gonna make a kind of ecommerce store on this page. We're gonna list out a section where we have some different roducts for sale. And then underneath it will have another section where you list out the number of items that a user has in a cart. One thing you wanna make sure is clear right away is that we're working with 100% fake generated data here. We're not gonna make use of any API or anything like that. In addition, we're not gonna have any kind of interaction. So there's no actual adding items to a cart or anything like that We're really just trying to get some plain text to appear on the screen. And when I look at this application, I really see two distinct features. First off, we've got a listing of different products are available for sale And we also have a display of the cart. It's going to list out the number of items that a user has in the cart. And remember that number right there. So when it says one item, that's really just a randomly generated number, then we're going to stick inside there. So when we notice right away that we've got two distinct features, we might decide if we were making some kind of monolithic style application to do something like this. We might have some kind of a component that displays a product list component and a cart component. So again, this is what we would do if we were making a classic or traditional monolithic style app. But how would we approach this if we were making use of microfront ends? Well, we might decide to take each major feature of our product and put it into a different microfront and application So we could have microfront end number one that contains all the code related to our product listing feature. So essentially all the code needed to get this list of products to appear on the screen. We might also create a 2nd microfront end app that contains all the code needed to get this cart to be displayed on the screen. You'll notice right away that if we only have these two microfront ends, we might have a little bit of a challenge in actually getting these things to be displayed on the screen. In other words, how do we know that the microfunding number one needs to be displayed up here at the top and microfund end #2 needs to be displayed down here at the bottom to coordinate where to show each of these different microfront ends on the screen and when to show each of them. We very frequently end up creating a 3rd microfront end app that we usually refer to as the container The container is what decides when and where to show all the different microfront ends that we have So to build up this little fake ecommerce store, we're going to end up making 3 small projects. We're going to make this container A. We're going to make microfronted number one to show a listing of Roducts and microfunded number two to show the cart. We're going to decide when and where to show each of these microphone ends by adding in a little bit of logic to this container application. So let's get started on putting this all together in the next video.

## Understanding Build-Time Integration

* In the last video I mentioned that this container is going to decide when and where to show each microfront end. So that really implies that the container needs to get access to the source code of the product list and the cart at some point in time. So in this video, we're going to focus on the different ways of implementing that. We're going to focus on the different ways of making sure the container gets access to products list and cart. This entire process is referred to as integration. So whenever you hear the term integration, you need to think about how we're going to kind of assemble together or orchestrate our different microfront ends

### Integration

* Now, before we talk about any different method of integration, I want you to know that there are many different solutions, or many different ways, of putting integration together. But out of all these different possible solutions, none of them is perfect. They all have their upsides and their downsides. So deciding on when to use is really going to come down to what your requirements are for your application. Now, in general, there are three different categories of integration We have built time integration, which is also known as compile time. We have runtime, which is also known as client side and server. We're not going to focus too much on server because it requires a ton of back end code that we're not really going to get into inside this course. So we're going to focus a lot more on build time and runtime integration. Whenever we hear about build time integration, we are saying that we are going to make sure that our container gets access to the product's list source code before the container is loaded in the browser. With runtime integration, we are saying that the container is going to get access to the products list, and the carp source code after the container is loaded in the browser. So a very small distinction there, but it turns out that that distinction is rather important. So let's take a look first at an example of build time integration.

#### Build-Time Integration

* So this is one way of implementing build time integration. It is definitely not the only way. There are other methods of implementing real time integration, but this is a pretty straightforward way of understanding it. So with a built on integration approach, we might have one team that is in charge of developing the products list application. At some point in time, they're going to finish up their project, and they're going to say, ok, time to deploy the same At that point in time, the products list team would publish products list as an npm package. So they would take all the source code for it and publish it off to New Mexico and make it available as a package that could be installed into another project. Then the team in charge of container would install products list as a dependency using that same kind of npm install command that you're robably already familiar with The container team would then build up their application. And the result of that would be a bundle that has all the source code for container and all the source code for Roducts list. So that bundle right there implies that we have one javascript file, or possibly multiple, that has all the source code for products list and container put together. Now, there's some definite upsides and downsides to this approach. The first big pro is that it's really easy to set up this flow, and it's relatively easy to understand as well. You've robably already implemented a flow very much like this, without even really realizing it. If you've ever installed some kind of 3rd party component into one of your applications. So if you install a 3rd party component, you have taken use, or you've made use of some package that's been published by another team of Engineers. And you made use of it inside of your project The downside to this approach is that anytime the products list application needs to be redeployed, we would have to redeploy the container as well. The other big downside here is that, because the container has full and direct access to all the products list source code, it might be a little bit tempting to somehow tightly couple those two projects together, which is something that we don't really want to do in a microfront end architecture Okay. So that's an example of a build time integration. Let's take a pause right here, and then take a look at runtime integration as well in the next video.

#### Runtime integration

* Let's now take a look at what a runtime integration would look like. So here's an example of one possible way of imlementing a runtime integration. Once again, we might have an engineering team that develops the products list alication. They would eventually decide that it's time to deploy their application. And at that point, rather than deploying their project to say NPM or something like that, they would bundle up their project and deploy it to some static url, something like, say, my app.com slash products list .js. So this. javascript file right here has all the source code for the products list application. So then whenever a user navigates to, say, Myappcom, we've been load up the container A. And at that point in time, the container app would then fetch that productslist .javascript file for js file and execute it. So notice that in this approach, the container only gets access to the source code of products list after the container has been loaded into the browser. Now this approach has upsides and downsides as well. So the runtime integration, the big upside is that we can independently deploy the product list alication at any time without having to redeploy the container. That's definitely a big upside. Another big upside is that we can easily have different live versions of the products list application. So we might be doing some kind of AB testing where we have two versions of the products list. And it can be up to the container to decide which of those two versions to use. The downside to this approach is that the tooling and the setup board is way, way more complicated. And there's really a lot more going on here that you have to understand as an engineer. Having said all this, and having kind of compared a runtime integration versus a build time integration, in this course, you and I are going to be focused 100 a on a runtime integration. And we're going to implement it using webpack module federation. The reason that we're covering this inside this course is that it is definitely the hardest thing to set up and to understand. And so in my opinion, it makes it way more sensible to cover this inside of a course where I can essentially walk you through everything use by piece and help you really understand what is going on now. Let me be clear, you might be saying, hey, Steven, I don't want to do the hardest thing here as I'm just getting started. Don't worry. When I say hardest to set up, I just kind of mean relatively. It's still, it's not going to be ridiculously hard. I just want you to be aware that we're going to be doing this approach because it just makes a little bit more sense to cover it in a course where you can have a lot of kind of guided instruction as you go through. The real reason that we're using this approach is that it's definitely the most flexible and performant solution for doing integration right now. One of the big downsides, however, is that we're going to have to spend a lot of time around web pack and really understanding what webpack is doing for us and how it works. If you don't know anything about Webac right now, that's totally fine. I'll give you a really good overview in the coming videos. Okay, so now we've got a better idea of what's going on. Let's start to tackle our application in the next video.

## Project Structure

* Let's take a look at how we're going to implement our ecommerce project using a runtime integration. To get started, we're going to create a separate folder for each of our different microfront ends So one forward container, one for card and one for products. Each of these different folders Internet that project and get it running in both isolation, in other words, by itself and as a part of the overall application. Everyone of these 3 different folders for this project is going to have the same different files inside of it. So we'll have an index dot js file with some implementation. We'll have an html file, a package dot json file, to list out all this sub projects dependencies. And then finally, a webpack config file as well. Each of our different sub projects are going to be built without using any javascript framework. So for this first go, no react, no angular, no view, just plain javascript. And again, we want to make sure that we can run each of these in isolation and through the container A as well. We're going to first focus on the implementation of the products microfront end. So just products by itself. We're not going to worry about the container or anything like that. To get started, let's open up our terminal. We'll create a couple of different files and folders. All right, I'm going to open up my terminal.

### Setup

* And once I'm in my tremell, I'm going to make a new workspace directory that's going to eventually hold all of our different sub projects. I'm going to call mine ecom short for ecommerce. I'll then change into that directory. And inside there, I'm going to make my first sub project. I'm going to create a folder called products and then change into that as well. Now Inside of products, we're going to first begin by generating a package Jason file. We'll do that with an NPM init -Y Once we've created that file, we'll then install a couple of different dependencies. Now as we install these dependencies, I really must ask you to use the exact same versions I'm going to use. This entire field of microfund ends is very fast moving and I could just about guarantee that if you don't use the same version as I, your code will probably break at some point in time. So we're going to do an em install. And we will install Webac at 5.4. We will get webpack cli at 4.2 Wet pack dev server. At 3.11 .0. And then just two more Baker at 5.1 .0. And finally html web pack plugin at. 4.5 .0. I apologize for all the typing. But like I said, really important for us to just make sure that we're using the exact same versions of all these different modules. So I'm going to start that installation process, and we'll come back together in the next video and move on from there

### Generating Products

* All my dependencies are installed, so I'm not going to open up my code editor inside of this product's directory, and we're going to start to put together some basic implementation for the product list. To get started, I'm going to create a src directory inside of here And then inside of that folder, i'll make a new file called Indexjs So eventually inside this file, we're going to want to generate a list of products and show them on the screen to our users. But right now,list of product. we're going to want to generate a list of products and show them on the screen to our usersAnd console login instead. I'm not going to worry about trying to render them onto any screen or anything like that. To generate a fake list of products, I'm going to make use of the Baker module that we installed just a moment ago. The Baker Library is used to generate fake data. That's all it does. Nothing else. So we can use Baker to generate some fake product names and stuff like that. To make these big product names, I'm going to create a new variable with a let keyword that I'll call products, and going to assign that an empty string I'm going to create a for loop. And iterate from zero to I less than 3. Inside of here will generate a product name using the Baker Library. So I'll do a faker dot commerce dot product name Double check your spelling on commerce right there. Just make sure you've got the correct spelling. That's going to give us a fake product name, which will work for the purposes of our application I'm not going to join that into this product string. I'm going to join it in essentially as a little bit of html. Again, right now we're just going to console log this out right now, but eventually we will render it onto the screen. I'm going to do a products plus equals and then a set of Bactics. And inside of a division, I'm going to print out. Name like cell. And then finally, at the bottom, after the 4 loop, i'll do a console log Of products Ok, so just a very simple, very basic implementation for right now. So if we wanted to run this as it stands right now, we would get a lot of errors if we tried to execute this code inside the browser. And that's because a lot of browsers do not have support for import sevents right now. So rather than trying to execute this code directly, we're going to instead use that web pack dependency to install just a moment to go. So remember, I mentioned that in this course, we need to have some reasonable knowledge of web pack and how it works. So let's take a pause right here when come back to next video. We're going to use webpack to transform our processes file. And in the process, we'll get a good review or overview, depending on how familiar you are with it around webpack

### Some Background on Webpack

* Let's set up webpack so it processes Excellent processes this index js file. Like I said, We're going to get a better idea of how webpack works in general. So to get started inside of my root project directory, I'm gonna make a new file called Make a new file called Webpack config.js Than inside here. I'm going to do a module dot exports of an empty object. And the only thing we're going to write inside of here is mode develop. Like so. Then after that, we're going to open our package .Json file. Now I'm going to find the script section inside of here. I'm going to replace the test script with start And we're going to have the start script just run wet pack for right now. I'm gonna make sure I save both these files I'll then go backward my terminal, and I'm going to run that start script. So back at my terminal inside the products directory, i'll do an npm run start. We're then going to very quickly see a ton of output scroll across the screen. It looks like something was built successfully. Okay, that's good. Let's really investigate what was created and what just happened behind the scenes with webpack. So back inside my editor, I can find a new directory inside of here called Dist, Shortcord distribution. Inside there is a main dot js file. I'm going to open that file U. Now, right away, you're going to see a tremendous amount of content inside of here. And the vast majority of it is probably going to be very hard to read and understand. That's totally okay. I just want to point out a couple of different qualities about this file. But first, let's take a look at a diagram very quickly. OK
* So we just wrote out an index js file. Inside that file, we wrote out an import statement to get access to the Baker module. The Baker module is not just one single file. Instead, faker is composed of many different files internally. When we wrote out that import statement, we were essentially saying that we want to appeal a collection of different files from that Baker module and make use of those different files inside of our index dot js file. So we can really picture the code that we just wrote out as being like the left hand side of this diagram, right here We created an index dot js file, and we imported into it a couple of different dependencies. We can see all the different files that constitute the Baker module. If we take a look back at our terminal You'll notice that all these different lines are referring to different files within the faker module So I've got something around Baker, some more Baker. These are all files around Baker. So we can see very easily. There's a lot of different files that are being included, just we can make use of Baker. Now, of course, when we start to load up all of our code inside the browser, in general, as real thumb, we do not want to load U many different files. Instead, it usually makes a little bit more sense to load U as few files as possible. Now there's a lot of different variations on that rule, and it's not a hard and fast rule, but in general, we don't want to try to load up hundreds of different files into the browser. And that's where webpack comes into play. So the goal of Webpack is to take many different javascript files, which we have right now, even with one single dependency And combined the mall down to one single output file, which in our case was named by default main dot js. That's the file we just saw inside of that disk directory. That main .js file is the output of Webpath. You will frequently see that file also named as bundle as well. So that one single file contains not only the code from our index js file, but also all those different files from Faker as well If we go back over to our editor and take a look at the main dot js file, we can scroll through here. And even though a lot of this code looks really confusing, you can see that there are references to Baker Index .js. So that's the index .js file inside the Baker module We can see some stuff around addresses and commerce and company. These are all different files, all of the different code inside these files have been extracted and thrown into these different eval statements. So you'll notice this evil function. If you scroll all the way to the right hand side, it's a really, really long line of code. This one line contains all the code out of that 1 file inside the Baker module. So we can see very easily that web pack is taken all the code out of these different files essentially place them into this one main dot js file We can find the code out of our index dot js file. If we go down to the very bottom of this file and then scroll back up just a little bit And you'll see right here a comment for src index js. So that is our file. So all the code out of our index .js file is contained inside this eval line right here. You will notice that there's a lot of extra code inside of here as well, just due to how web pack processes are code. If you scroll over to the right barn up, you'll eventually see some stuff around creating that product string. And then our for loop. The body of the for loop. And then eventually the console log of products right there. So at this point in time, all I really want you to understand around Webpack is that we throw in some collection of files. It somehow combines all those files together into one single file, and we get this output named either bundle or main, or any other other couple of names. We can really name that file anything we want, but usually by convention it's called either main js or bundle js. Okay, so now you've seen a little bit around web pack. Let's start to expand a little bit more in the next video.

### Touch More on Webpack

* We've now got our name As file created, but just creating this file doesn't really do us a whole lot. We now want to somehow take this file and execute it inside the browser and make sure that eventually the code inside viewer generates some html that gets displayed on the screen. So we need to load up main dot js into the browser. To do so, we're going to first set up a little module called Webpackdev Server. Webpackdev server is going to take the output from our webpack process and make it available in the browser To set up webpackdev server, we already installed it just a moment ago. All we have to do is make a change to our webpack config file. So back inside of our editor, I'm going to find the Webackconfigjs file. I'm going to add a new section inside of here of dev server. Make sure that server has a capital S. Then I'll put in a port of 8081. That's really important that you use a port of 8081.
* Later on, this port number is going to become very critical. And we need to make sure that we've got absolutely identical port numbers, otherwise you're going to have to figure out some configuration steps on your own. I'm gonna save that file, and then to make sure that I run webpack with dev server enabled, I will also go into my package dot Json file. I'm going to find the start script again, and I'll update the command to webpack serve like so I'll then go back over my terminal and let's run npm run start once again After another little pause, we'll see a message right there, very briefly, that says that our project is running at localhost colon 8081. Now we can access the main dot js file that was created by opening up our web browser. And navigating to local host 8081 slash main dot JS. And there is the contents of our main.js file. You'll notice that we are seeing the contents of the file, which is not really useful to us. We don't want to see the contents. We want to run this file to run the file. We have to create an html document and then reference this main dot js file using a script tag. So let's go through that process as well right away.
* Back inside my editor.I'm going to create a new directory that I will call public. Then inside that public folder, I'm going to make a new file called index.html At the very top, I'll put in a doctype I'll put in an html tag Ahead. A body. And that's all I'm going to put in for right now. You'll notice that we don't have any scrit tag inside of here at all. Well, it turns out that when we are making use of Webac, we are not going to try to manually reference that main dot js file. Instead, we're going to have webpack figure out how to add the script inside of here for us. Let me show you a diagram to help you understand why we're going to do that. Ok so event Actually, we want to load up an html document inside our browser that's going to have a script tag that tries to load up that main dot js file. We should see some kind of scrit tag that says something like source main dot js, or something like that. We could definitely add that in manually. But as you're going to see very quickly, and I can actually kind of modify our index js file to do this very easily, we might eventually have files coming out of Webpack that do not have predictable names. Right now, our file that comes out once it's been joined together is always going to be called main dot js. But it's very. easy to accidentally make some changes to your project, and you're going to eventually want to make these changes And that's going to have web pack spin out some file names that have dramatically different names. That are absolutely unpredictable. So it might have some kind of identifier like this, right at the start of the file name. And these different identifiers are going to be really hard for you to guess. O, we can't really just have a static script inside of our html document, because it would be really challenging for us to guess what those identifiers are always going to be. So instead, we're going to make use of a little plug in called Webpackhtml Plugin. Actually, I think it's called html webpack plugin. This plugin is going to take a look at the different files that are coming out of Webpack. It's going to take a look at those file names and then automatically update that html document we just put together to add in some script tags that specifically reference these very specially named files. So this plugin is essentially going to create for us and add into the html document the rescript tags with the name of 1 K4J43 bundle. and 4 6J3JI.bundle. And the last one right there as well. So this plugin will make sure that we always load up the correct output files that are coming out of webpack. So let's set up that plugin and tell it to modify that html document we just put together To do so, we'll go back over to our web pack config file at the very top. We will import that plugin with html weback lugin And then at the bottom of this object, I'm going to put in a plugin's array inside there. I'll add in new html web ack lugin We're going to pass it in object, give it a template property, and tell it to use the html file inside of publicindex dot html. So this plugin is going to take a look at whatever files are coming out of our web pack process. It's going to find those file names and then add the appropriate script tags automatically behind the scenes to this html snippet right here. OK, so let's save thisWe'll go back over to our terminal, and we're going to restart webpack. We're going to do a control c And then another mpm run start. And now, if we go back over to our browser And go to local host 8081 without any file names or anything like that, and open up our console. We will see our console log from our code O. It looks like the contents of our index .js file is now correctly being executed. We can also make changes to that file at will. So how about back inside of our index dot js file? Let's now do everything from zero up to 5. We're going to do an I lesson 5 right there. That should automatically be updated by webpack So back in our terminal looks like webpacks saw the update we just made to that file. And if we now go back over to our browser, it looks like the console log has automatically been updated as well. And we now see five products being generated Ok, so that is the basics of Webac. We've now gone through the process of having webpack in cat meat together, not really concatenate, but combine together a bunch of different files, roduce 1 output file. And we are now loading that file up inside of our browser. Now, if all this stuff is just total review for you, I apologize for the review on Webpack, but it's really important for you to understand these basics. Because as we go through this idea of module federation inside a wet pack, it becomes super critical for you to understand what is going on behind the scenes with webpac so Just take a pause right here and continue in just a moment.

### Finishing the Product List

* To finish off our products microfront end, we need to make sure that our list of products we've now generated somehow gets displayed on the screen to the user. To do so, I'm going to open up my index HTML file inside of that body element. I'm going to add in a new division with an ID of dev dash products. And closet div off. I'm going to save that html file. I'll then go back over to my index dot js file. I'm going to delete the console log of products. And I'm going to replace it with a query selector For that element we just created, and to show our list of products on the screen, we're going to set that element's inner html property to Roducts. Do notice that inner html, the html right there has all capitals. So let's now save this file and go back over the browser and just make sure that our list of products is being displayed Yeah, there we go Well, believe it or not, that is kind of it for our products microfront ends. We are now generating a list of products and showing them to the user. But that's not really the end of what we need to do inside this project. Right now, we have developed a stand alone application. This thing works by itself, but there's really nothing inside of it to ensure that we can somehow integrate this with our container application. So let's have another quick pause right now. When we come back, we'll figure out how we can somehow plan a random integrating products with the container app once we build it.

### Scafolding the container

*The products microfunded is now in a pretty good state, so now we're going to start to work on our container and then figure out how to integrate these two microfront ends together. So let's start working on container. I'm going to 1st begin by going back over to my terminal. I'm going to open up a 2nd terminal window You'll notice that it is automatically open for me inside the products directory. I'm going to go up one directory. So I'm back inside of our ecommerce folder. So I should see our products roject right there. So once I'm inside of the econ directory, i'll then make a new folder to house everything related to our container. I'll change into that container directory. And then, once again, I'm going to create a package dot Json file with New Mexico init Y Once I've generated that file, we're then going to again install a couple of different dependencies. These are going to be the exact same dependencies that we added in to our products project with one exception. We're not going to add in the Baker module to our container because the container just doesn't need it for any reason. So we will do an npm install. We're going to do html web pack plugin at 4.5 .0. We'll get node mon we don't need to specify a version on that. We'll get web pack at 532 Web packed cli at 410. And then finally, webpack dev server at 311 0 I'm gonna run that. And while that's going, I'm gonna flip back over to my code editorInside my code editor, I can currently only see the product's directory. I'm going to reopen my code editor so I can work on both the products and the container projects at the same time. To do so, i'll go to file and then open I'm then going to select my ecom directory. And open that. Now, if you're in windows, the process will be just slightly different. But ultimately, all we want to do is open up the ecom project inside of our editor O. We should see both our container and our roducts folders.

* Ok so now we're going to do a little bit more setup on our container. The setup inside of here is going to revolve around the exact same files we had created for our products. But some of the files are going to have some different configuration and code inside them. At the end of the day, though, we're going to have to be pretty much the same files in index .js and html file and a web pack config So I'll first begin by creating that index html file. I'm going to create a new directory called public. And then an index.html inside there I'll place my duck tight. An html tag There's my head. My body And we're going to leave it just like that for right now. So one thing I want to point out here is that inside of our container html document, we've got an emty body. And inside of our products, html file, we've got a div where we can render our actual products project. So that list of projects are going to be inserted into that div right there. So it's going to point out really quickly that these two html files are just slightly different. Next up inside of our container, we're going to make another folder of src Inside there, I'll make a new file called index .js. And right now I'll do a very simple console log, and I'll just say, container I'll then save that file and close it. And then finally, we'll make one more file, the Webpackconfigjs file So for right now, this file is going to look kind of similar to what we just did over inside of products. But we're going to very quickly make some big changes to it. O inside of here, we still want to have that html webpack plugin And I'm going to require that from. Html web pack plugin will then do another module exports. We'll set our mode to development. We'll set our dev server. And this time around, for our port, we're going to say 8080O. At this point in time, remember, our roducts roject is on ort 8081. And our container is going to be on 88. And then finally, we'll set up our plugin's array. We'll have a new Html webpack plugin. We'll set the template To be publicindex html Ok, just one last piece of setup inside of our package dot Json file. We'll make sure that we add in our start script. O, I'm going to replace inside of ackage .Json inside the container directory, test, hit start. And whenever we run that, we're going to actually execute our. Wet pack serve like so. Ok, so we've now got products, and we've got container. These are two separate projects. There's no link between them. There's no tie, there's no integration at all. Just make sure the container is working by itself. Let's go over to our command line, make sure we can launch container, and then just try to visit it inside of our browser. So back at my terminal, it looks like my MPM install is all complete. I'll make sure I'm inside my container directory, and I'll do an npm start or an npm run start. Either one is totally fine. OK, so looks like everything has started up I don't see any errors. I might see a warning or two fully fine. Now, to make sure that our container is working correctly, I will open up my browser once again And then I will navigate manually to localhost 8080. And I should see inside my console something that says container like so. Ok, so we've now got two rojects created, and now we need to think about how we're going to integrate them together. So as you can guess, that's going to be a big topic for our next video. So quick pause right here, and we'll dive right in.

## Implementation Module Federation

* We've now got our container and products projects in a pretty good state, but now we need to make use of somewhere from inside of our container. Can you just set up our integration process to start to do inside this video? So let me show you a diagram. I'm watching the steps we're going to go through. Okay, so we're going to go through this one by 1. We're going to go through all these steps rather quickly. And in the coming videos, we're going to go into great detail. I'm going to explain what all these different steps are about. So to get started, we're going to 1st designate 1 application as a host and 1 as a remote. Our host is going to be the application that is trying to make use of code from another project. So for you and I, our host is the container. the remote is a project that is making the code available to other projects. But you and I are remote. Next up inside of our remote, which, again, is products. We're going to decide which modules or files really is what we call them. You want to make available to other projects. So for you and I, right now, this is a really easy decision to make inside of our products project. There's only one source code file available, and that is our src index .js file. This is the only file that we can somehow make available to other projects. So we want to make index dot js available to other projects inside of our overall project. onto step number three. This is where things are going to start to get really interesting to somehow integrate these different projects together. We're going to use a plugin from webpack called the module federation plugin. Like I said, We're going to go into great detail about what all these things are about very shortly. But right now, let's just set up this plugin. To do so, I'm going to find the webpass and face file inside of my products directory. Then. at the very top, I will require in module federation plugin from Webpat Slash Lid slash container slash module federation. Got that required statement. I'll then find my plugin's array. I'll do a new module federation plugin. And we're going to provide a couple of options to this thing. First, we're going to put in a name of Roducts, a Of remote entry dot js. And then finally, exposes. It's opening to that. This is gonna be enough. I'm gonna Yes. And then finally, expose this. This is going to be an object with a key of dot slash products index and a value of dot slash src index Now I'm sure all these different options right here, right now, look a little bit mysterious. Like I said, Don't worry. We're going to come back and understand what this is all about. O, I'm going to save this file and then close it. Now we'll move on to our next step inside of our host, which is our container. We're then going to decide which files we want to get from the remote. So in our case, once again, really easy decision. There's only one file available. The only file that we can get access to inside of our host is the index dot js file inside of products. So we want to get access to that file Once you've decided upon that, we're going to set up the module federation plugin inside of our host as well. So inside of our container, web pack config js We're going to again require Module federation plugin. From web pack lid container. Module federation plugin. I'll then go to my plugin's array. I'm going to set up in a very familiar, very similar way. So new module federation plugin. And it will pass it a couple of options So in this case, we're going to add in a name of container. And then a remote that's going to be an object. Open in Roducts, and I'll put in a string gear. And the string is going to look a little bit confusing. So please double check your spelling and your all your typos inside of here. We're going to put in products at http colon slash slash localhost 8081. Remote entry js OK, there's our setup inside the host Now, this next up, once again, a little bit confusing. Don't sweat it inside of our host. We're going to do a little bit of a refactor. All we have to do inside of our container directory, we're going to find the index .js file. I'm going to rename that file to bootstrap. Now we've got bootstrap dot js. And then inside of src, I'm going to make a new file, also called index .js And inside of here, I'm going to put in an import function call. So notice we don't have an import statement. It's an import function call. And we are going to write in there dot slash bootstrap like so And then finally, inside of our host, we're going to import whatever files that we need actually need from the remote So for that, we're going to try to figure out, hey, where do we actually want to make use of our source code that we're importing from products? Well, we probably want to get access to all that source code inside this new bootstrap dot js file. And I see probably, but that's probably not really clear why I say probably just yet. Don't sweat it right now, just inside a bootstrap js at the very top. We'll put in an import of products, slash products index, like so And that should be it OK for the 5th time in this video. I just want to mention I know a lot of this stuff is probably really mysterious, really confusing. Don't sweat it. You can go over it step by step. I apologize for repeating that, but just want to make sure it's super clear. Now, to test everything out, we're going to go back over to our terminal and restart our web pack processes. So back at my terminal I have two terminal windows open. I've got one right here for my container for my products. And then the other 4 container. But I'm going to stop both these with the control So here's products folder and the container folder. And inside of both them, I'm going to do another npm run start. OK, so now we're ready to test everything outside the browser. And I want you to know that when we run this in the browser, we might end up seeing an error message. But that's truly okay. We're going to fix it up really quickly. So back inside my browser, I'm going to navigate to local host 8080 And then once there, I'm going to open up my console, and I might see some kind of air like this. Something that says, cannot set property inner html of null. So we're seeing this error right now because we are trying to run some code from our products application. If we go back to products and find index js, remember that when we load all this code and execute it, we try to find some element on the screen with an id of Devroducts. And then we try to set its inner html. So right now we are running this code inside of our container project and inside of our container project. We don't have an html element with that selector. So to get our code to work, we're going to very quickly go into our public index dot html file inside of container. And inside that empty body, I'm going to add in a div With an id of dev dash products. On and save the file. Flip back over. And sure enough, at local host 8080 we now see our list of products on the screen. Remember, localist 8080 is our container application. We can also see a console log of container right here. So I think at this point in time, it's pretty clear that we are inside of our kind of container application environment, but we have loaded up and executed some code coming from our products application. So this is definitely good, but a lot of mysterious code. Let's take a pause right here and then start to figure out what is going on in the next video.

### Understanding Module Federation

* We've now set up some integration between our products project and our container. Let's now take a look at justice our configuration around products and really understand what the module federation plugin inside the product's webpack config file is doing for us. So I just want to focus on this module federation plugin inside of products for right now. OK, we're going to take a look at a couple of different diagrams, but first I want to go back over to my browser. I'm still at local host 8080. Once here I'm going to open up my console. I'm going to go to the network tab. I'm going to filter requests by Javascript files, so now we're only going to see requests that are trying to load some Javascript and then I'm going to refresh the page. I'll then see a couple of different files are being loaded. Now remember, we're at local host ad right now, which is the port for our development server, for our container alication On the system files, I'm going to right click anyone of the headers and then enable the url column. Once I get that column up, I can take a look at where all these different requests are being made to. You'll notice that three different files are being made to localhost 8081 which is where our containers meet our roducts development server is running. So when we go to our container application right now, it looks like we are loading up three different files from products. 1 file is called remote entry. Another is called source index js. And another has a really long name that seems to be related to our faker dependency. Generally, we've identified these three different files. So we are loading up from our products project. Let's take a look at a diagram and understand what they're all about. Ok, so here's a diagram of what's going on inside of Justice. Our products roject for right now.
* So we still have products. We still have an index js file inside there that makes use of the Faker module. When we start up Webback with this module federation plugin, we are now emitting two different sets of files. We are still bundling up that index dot js file as usual. And we are spitting out a main dot js file that includes everything from index along with all the dependencies that that thing requires. I only mention this because that means that we can still run our products project in isolation without having to worry about running a container or any other application So we can still develop our entire products application in a kind of standalone environment. By adding in the module federation plugin. However, we are now emitting a second set of files. The Module Federation plugin is causing us to output another set of files, which are the remote entry file, source index and something around Faker as well. These are the three files we just saw inside of our network request log. The first file remote entry js is a javascript file that contains kind of a manifest of sorts. It lists all the other files that have been emitted by the module federation plugin, and also has directions on how to make use of them. The remote entry js file can be thought of as being kind of a set of directions for other projects, like our container. The set of directions tells the container how to load up some source code from the products project So that promote entry js file will tell our container that if the container needs that sourceindex js file, well, here's some directions on how to go and fetch that file. And if it needs something around the faker module, here's some directions on how to fetch this file as well. The sourceindex .js file in the Fakerjs files. Once again, we saw these inside of our network request log just a moment ago, or essentially identical to the index js file we've got inside of our roducts project and the actual fake dependency. But they've been processed by Webpack. So rather than just having the exact code that we have inside of our code editor, such as this right here, wet pack will take all this code and convert it so that we can make use of modules like import statements and stuff like that inside the browser. Long story short, the version of this sourceindex .js file and this faker stuff that Quit from the module federation plugin can be safely loaded and executed in the browser. Let's go take a look at the source code for source index JS inside of our browser right now, just to see what it looks like once it's been processed by the module Federation plugin O back over here. I'm at my network request tab once again. Here is source index JS and I can see that it's been loaded from our products project. If I click on that. And then go to the either preview tab or response We're going to see some source code inside of here that essentially says, here is the source code from the actual sourceindex .js file. All the source code from it is inside this eval string. And inside there we can see that there's some direction saying, hey, we need to load up faker. And then eventually, once we load faker, we're going to create that product string, do our for loop, build up the list of product names inside of a div, and then eventually render that output to some element that's inside the Dom So you can see very easily that. this file right here has all the same code from our real source in Xjs file, but it also has some stuff and checked it into it by weback that says here's all the other dependencies that this file requires to run safely Ok, so at this point in time, we've really established what's going on with the module federation plugin when it is running in a remote mode. Or essentially, when we are telling the Module Federation plugin that we want to take some code out of our current project and make it available to other projects, the Module Federation plugin spits out this set of files that includes a set of directions on how other projects can get access to the source code of products. So now that we understand just that piece, let's take a pause here and then understand what the same plugin does over inside of our container application.

### More on Module Federation

* Let's now take a look at the module federation plugin does for our container application. So we're going to take a look at a very similar diagram. The first thing I want to address is the fact that we had created a 2nd file called bootstrap.js He did the integration process. So back inside of our editor, here's my container application. We now have a bootstrap js file, which contains our actual alication code and an index dot js file. And inside of index dot js, all we are really doing here is importing the bootstrap file and nothing else. And what's more, we're using some different syntax for the import. So what is this index dot js file all about? And why do we add it in? Well, this really gives Webac the opportunity to realize that before executing that bootstrap dot js file, we have to go and fetch some code from the products project That's what the index .js file is for. It is just to allow webpack that opportunity to go and get some additional javascript and make sure that we've got the project code or something that products code ready, along with the faker code ready as well. Before we try to actually do something with it, when we actually execute the contents of the bootstrap dot js file, the expectation is that we will have access to this module in all the different dependencies that it requires. So if we try to go directly into our bootstrap dot js file, in other words, if we try to execute this first, we would end up with an error. We would end up with some kind of message that says, sorry, but we don't have any code for products. We don't know where to get that code. We don't have it available. So by adding in the index .js file, we are just giving web pack an opportunity inside the browser to go and fetch some dependencies from products before actually executing the code of bootstrap. We can kind of see this rather easily inside the browser. So if we go back into our browser, open U that network request tab again, we can take a look at that mainjs file. O, if you click on it And go to either a preview or response. You can then go down to the very, very bottom the file, and then scroll back up just a little bit. And you might see an entry right here for source index .js. This is the index.js file inside of our container. We once again have this string with all the code from it. You'll see that the code has been transformed a little bit. And so now, rather than just having something that says, import bootstrap, we've now got something that says, require in bootstrap js or source bootstrap js. And then. after that, try to execute the code inside it. So Long story short, once again, this is really just giving us a really giving web pack the opportunity to go and fetch some code from products before running our index.js file. Ok, so back over to this diagram. So again, inside our container, we've got the index dot js file that's really generating main dot js. And then our bootstrap is really being output as a separate file. We first run mainjs, that's going to try to fetch some additional code from products and then execute the code inside of bootstrap js. Now let's start to put our container and our product stuff together inside of one diagram and understand the real flow of what's going on Ok so in in the browser, we've got a series of steps that go on. We've then got whatever is coming out of our webpackdev server for a container. And on the right, we've got products. When we first go to localhost, 8080 the first thing you do is download and execute the main dot js file from our container. Once we execute that file, webpack then sees a require statement saying that, oh, we need to import and somehow execute bootstrap js. So wet pack is going to start to download that file. As it starts to download that file, webhack also realizes that it needs something from the product's project in order to execute bootstrap. So simultaneously, as it starts to download bootstrap dot js, web pack inside the browser is going to fetch remote entry from our products application This remote entry at JS file says that in order to run bootstrap js, we have to download source index.js and faker from products as well. So web pack is going to download. Source index js and everything for faker Once it has completed the download for bootstrap or source index and for faker, now it finally has all the code that is needed to actually execute bootstrap. So it runs the code inside of bootstrap. We've got everything from products including the source index.js file in Baker over there as well. Another way that we can really verify this entire process is by taking a look at the sequence of requests that are being executed. O back over here, inside of our networkrequestlog, we can take a look at the waterfall chart. So inside of our waterfall chart, you'll see that the first game happens is we download and execute the main dot js file. Once we execute that file, we then realize, ok, we also need something from products, and we need that bootstrap file. So simultaneously, web ack goes to download the bootstrap file, and it also knows that it needs to download the remote entry file to figure out how to get some code from the products project. Once it gets the remote entry file, it then sets up another two requests to get the Bakerjs stuff and the index .js stuff from Roducts. So it's only when these two requests right here are finished and we get the ability to execute the code from products that essentially all three of these different files are ram. The bootstrap Baker and index .js That's what's going on behind the scenes. Ok, so all the stuff I know is pretty intense. There's a lot of stuff going on here with this module federation stuff. And it actually even goes deeper than what I presented. It turns out that there's a lot of extra kind of corner cases around handling dependencies for stuff like Baker. We're going to explore some of that as soon as we start to add in our final microfund end, which is the cart application. So let's take a pause right here. We're going to come back the next video and make 1 or 2 changes to our products project. I want to point out one or 2 things around it that is not quite great right now. In some ways, we could probably improve some of the structure of our code So could pause, and we'll do some improvements in just a moment.

### Understanding Configuration Options

* At the end of Video I mentioned we're going to change some code inside of our products project, but before we do so, I want to explain some of the options that we provided to our webpack configuration really quickly. So specifically the options we provided to the module Federation plugin, we're going to first take a look at the options we provided to our container. So on the side of container, web pack and big dot js All right, here we go So the first option we provided was the name. The name is not being used whenever we are creating a host module. Remember, our container is a host. It is trying to use some code from some other projects. A name is only required when we are creating a remote. Remember, a remote is something that is trying to share code with the outside world. Even though this name property is not used because we are inside of a host, it is usually convention to add it in any ways. Next up, we have a remote section. The remote controls how web pack is going to try to decide whether or not to load up that remote entry file. Rather than taking a look at all the notes on here, let me just give you a very practical example of what this remote section is all about OK, so inside of our container project, I'm gonna find the src bootstrap dot js file. You'll notice that inside of here we've got an import statement that begins with a word product's O. When we build our project and it's compiled or processed by Webpack, Wepack is gonna see that we are trying to import a module that begins with the word products. If Wepat cannot find a product's dependency inside of our node modules directory, then it's going to take a look at the module federation plugin, specifically the remote section. Inside this object, it's going to see if there are any keys inside of here that have the word products. And sure enough, there it is, right there So this word products matches up with this key products right here. This tells Webac that to try to implement this imort or try to actually get access to this code, webpack needs to load up the remote entry file that is listed right here. So if we ever wanted to change how we refer to our products project inside of our container, we would change the word products right here. And this key right here. Let me show you an example of that. Maybe we want to change this to products app or something like that. Maybe that's how we want to import this thing. To do so, we would have to also go into our webpack config, find the word products right there and change it to products app I can then save both these files, and then go and restart my webpack process really quickly. If I then go back over to my browser, I can refresh the page, and everything still works as expected. So you only have to change this key right here if you want to change how you write out the import statement for this outside project. I'm going to very quickly change this back to Roducts and Roducts by so Okay. So that is the purpose of the key of that object. And the value is a string on the right hand side of that at sign is the url. And as you guess, that is where we should go to try to get the remote entry file to figure out how to load in some modules from this outside project The word on the left hand side of the at which says products is related to some configuration that we put into our web packs config firstly, our products, webpack config file A word on the left hand side of the app, right there. Products is a tricky little thing. I'm going to show you a little bit more around that in just a moment. So we're going to forget the word products right there for justice a moment. Okay, so that's it for our container web pack. File. Now let's take a look at our webpack config that we place inside of Roducts. Here's the diagram for it. I'm going to also open that up inside of my editor very quickly
* Ok, so now here we've got a name of products. That product's right there, that string has to be identical to that product string right there. That's what needs to match up. So if that string is not identical to that string inside the remote config, nothing is going to work as expected. Let me show you this in practice very quickly. So I'm going to open up my products, web pack and fig. I'm going to find that name property, and I'll change it to about just like my products like so I'll then save this. And I'm going to restart my web pack processes once again. I'm then going to go back over to my browser, and now I'm going to see this nasty air here. It says, sorry, but something went wrong. So again, the rule of thumb here is that name of products right there has to match up with wherever we are trying to make use of this module from has to be identical to that string right there. That's pretty much it. Now, beyond that, we've also got a file name that controls the name of the remote entry js file. There's just about never a very good reason to rename this file. I recommend that you just always place it as remote entry dot js. And then finally, we've got exposes. So the exposes object right here controls which modules or which files inside of our products project that we're going to expose to the outside world. So if we had many different files inside of products, we could choose to export all of them, or maybe just one of them, or as many in between as you want So in this case, we are saying that we are going to expose a module called products index. And if anyone tries to import something called products index, we want to give them the SRC Index file. So let's take a look at that as well. Back inside of our bootstrap js file. Remember, we had said products slash products index. So wet pack is going to get that remote entry file inside there. It's going to try to find something called Roducts Index. Inside of our webpack and fake for products, anytime someone asks for products index, we're going to instead give them source slash index, which is the index file inside of our products project. Now this line right here is probably going to be one of the most confusing things for you. You might be saying, wait, we are. We're essentially renaming something. That's what's going on here. It's an alias and you might be saying, wait, why would we ever do this? What's the point of it? Why don't we just expose everything inside of products and say, hey, that's it. You can just reach through and just take out any file you want, and it can have any arbitrary name. The reason that we have this kind of aliasing ability right here is because there might be some scenarios where the name of a file inside of our products project might be kind of only meaningful in the context of products. Let me give you a really quick example of that So crypt diagram. Here we go. So let's imagine that rather than making some kind of products thing, maybe we're making some kind of charting library, a library that generates charts and shows them on the screen or something like that. Maybe inside of our chart project, we've got some different files organized like so. Maybe we've got a bar chart directory and inside there is an index dot JS file and that file has all the code required to create a fire chart. Maybe we've got another one for making a line chart, a radar chart and so on. And so all these different files are named something like bar chart slash index line chart slash index and so on. This is a really small thing, but we might not want to write out inside of our container project something like import bar oregon, really be charts bar chart index. Adding on the index on there at the very end is just not super necessary. We don't really gain anything by putting on the word index and so maybe you would be just ever so slightly more convenient if we could just write out something like charts slash bar chart and be given that bar chart slash index .Js file. So that's. all. So that's all this kind of aliasing thing is doing for us is just making it so it's slightly more convenient to choose exactly the names and paths for all these exported files. That's all. At the end of the day, once again, all this really means is that if someone asks for the products index file, give them the source index file. And so again, back inside of bootstrap js, we ask for products index. And we got back source index.js from products OK, so again, if that part, that little aliasing part right there, is confusing, I apologize for that. But it's just reality. It is what it is. O. K. So that's a deeper dive into us configuration. I apologize for the last video being really long and this one being really long, but hopefully you've now got a better idea of what's going on with module federation. So let's take a pause right here and continue in just a moment

### Scaffolding the Cart

* Let's get started on our cart microfront. As a reminder, this little cart feature is just going to show the very simple text right here. This says something like you have one item or 2 items or whatever in your cart. The actual number is going to be randomly generated, so we don't have to worry about having any actual adding functionality or anything like that. The code for the card is going to be extremely similar to the products list, but as soon as we add in the car, we're going to start to run into a couple of difficulties. We're going to have to think about some different ways to resolve them. So let's get to it. Back inside of my code editor. I'm going to first begin by creating a new folder called cart, then to save just a little bit of time. I'm going to copy the package dot Json file from products. So here's a copy, and I'm going to paste it into cart Then inside the cart package dot Json file, make sure that you've got the cart one open. We'll just change the name of the project to cart. This name is not actually used anywhere. It's just a for record keeping. So let's now go over to our terminal. We're going to open up a 3rd terminal window that's going to be dedicated to running our cart project, and we'll install dependencies into it. So I'm going to open up my third terminal window. I'll change into the cart folder, and then do an empty install inside there Once I start that up, I'll go back over to my editor, and we're going to essentially create the exact same files inside a cart as what we have inside a roducts. But I would really encourage you to write these all out by hand, as opposed to just doing some copy paste, because it just builds a little bit of muscle memory. So let's get to it. I'm going to first create a new folder of public And I'll make a new file inside there of index html. So once again, do a doctype Html Ahead A body And I'll place a division with an id of dev dash cart. So that's going to be eventually where we try to render our current application into. After that, I'll make another new directory inside of cart. Of Src Inside there, I'll make a new file of index js. And inside of here, we'll have some code that's going to just require in or import in Baker. We're then going to generate our fake text to say, you've got so many products. And once again, just show it into that div element that we just created a moment to go So at the very top, I'm going to import in Faker All then put together a variable. We'll call it. How about message? How about cart text and call it anything? It doesn't make a big difference. I'm going to make this a temlate string. Put in a division, and I'll say, you have an dollar sign. Curly braces, Baker, random number. And then. items in your cart Let me zoom out just for a second so you can see that entire line So then after that, we're going to try to take that text and render it into that division right there. We'll do a document query selector. Cart dev. That the inner html to cart text like so OK, that's it. It's now our last thing inside of cart. I'll make a new webpack config .js file. So again, this is going to look very similar to one we just put together for our products application. At the very top, I'm going to require in htmlweback plugin I'll get my module federation plugin Then my module exports Set our mode to the development Start up a dev server. And then remember, we've already got a development server running on port 8080. That's our container. We've got one on 8081. That's products. So we will put our cart on 80 82. We'll then set up our plugins So for plugins, first do our new module federation plugin Remember, we need a name. Look at a name of cart. A file name ofremoteentry.js. Again, really no great reason to use any file name besides that. And then exposes And we'll do a string U dot slash cart show. And anytime someone asks for that cart show file, we're going to actually give them. Source index Or just index like so. And then finally, after that plugin We can put in our new html web app plugin. And there's our template of public indexhtml OK, that's it I'm going to make sure I save all these files, and then let's try to run our cart in isolation just to get started. O, I'm going to go back over to my terminal. Looks like my M install process is complete. So inside of my card directory, i'll do in npm. You know what? I just realized we forgot to put in our start script. Let's go back over to our editor, open up that package dot Json file. Oh, wait, no, we copied it. So it's good to go. My mistake. So, yes, we can go into our terminal and do an NPM run start. Now we should be able to open up our browser and go to local host. 8082 So I'm going to go to local host 8082 And it looks like I probably put together that id for that element incorrectly. That's my guess here. O, I'm going to just go check that out really quick. Ears cart dev. Oh, dev dash car. Yeah, that's the reason. So one was dev dash current, the other was car dash dev. It's gonna fix it up really quickly Now, if I go back over and refresh, here we go. So I've got 23,000 items in my cart. That's a lot of items, but whatever, it works for the purposes of our a okay. So we've now got cart running in isolation. Now quick pause right here. We're going to start the integration process into our container in the next video.

### Cart Integration

* Let's start to integrate our car project into our container. To get started, I'm going to open up the container webpack config dot js file. Inside of here, I'm going to find the remote section. I'm going to add in another property of cart, and then I'll give it a string of cart at http colon slash slash localhost. 8082 Remote entry js Then inside of my container, src bootstrap .js file. I'm going to import cart. slash cart show. So let me just give you a quick reminder on how this import statement works. First, webpack is going to see the word cart. The word cart is going to match U with the cart that we just added in to our container webpack config file. So it's going to see cart right here. And Webpack is going to understand that it needs to load up this remote entry js file in order to access our carved code. Once that file has been loaded up, we're then asking for specifically the cart show module Our current project doesn't actually have a module called cart show. So you might recall inside the cart webpack config file, we had set up this alias inside of here. So we had said that if anyone ever asks for cart show, we're going to actually give them source slash index. That's how we are ultimately getting cart source index.js into the context of our container. Just a little note on that aliasing feature. At this point in time, you can start to kind of understand that if we had an import statement of something like roducts slash source index and cart source index, it's kind of hard to understand what's going in here going on here with these imports. Source index doesn't really tell us what this file is all about, but if we have file names like products index and cart show, a lot more clarity, I could look at this name right here, and I've got reasonable suspicion that this is probably going to show a list of products on the screen and cart show is probably going to show some details about some particular cart on the screen. Okay, so this looks good. The last thing we have to do is make sure that when we import in cart show and run all the code inside there, we need to make sure there's some actual dom element that our cart is going to be able to render into So inside of my container, publicindex dot html are going to copy that division right there. And put down another division with an id, and I forgot what we ended up calling it. Kids, carpet. You'll notice that they're opposite in here. No big deal. We're actually going to come back and change these disks in just a moment Ok so I'm going to save all these files, and let's go and restart our container. So I'm going to find my container running at the terminal. I'm going to stop with the control C and then do another New Mexico run start Now we should be able to go Localhost 8080. And see both our product list and our cart up here on the screen. Awesome. So that means that we are loading U code from those two sub projects into our container. Now this is definitely really, really good, but there are some other considerations I want to throw out there, some stuff that's a little bit awkward about this project. I want to go into the next video.

### The Development Process

* We've now integrated all three projects together. So at this point in time, I want to take a very quick pop And just make sure that it's crystal clear how you would develop an application like this in the real world. Alright so quick diagram so we're going to imagine that maybe we have one engineering team in charge of each sub project O for team #1 they might be in charge of Roducts Team #2 might be in charge of cart and team number three might be in charge of the container teams number one and two can develop their entire application in isolation. In other words team number one can develop products by itself and they don't really have to care about what any other team is doing. They can have all their own dependencies all their own tooling The only requirement is that they make use of wet pack and they make use of the module federation plugin. That's pretty much it. So for team number one in order to develop their project all they have to do is change into the products directory run NPM start inside there they can then navigate to local host 8081 and see their application appear on the screen. They can then develop their products application in isolation. Same thing. 14 number two. The only difference is that they're going to go into the car directory and their application will be running at localhost 8082. T number three is the only one that's going to have any amount of crossover. The team number three would need to make sure that all three sub projects are running. So they would need to make sure they run npm start inside of them Art's products and container. Then they would navigate to localized 8080 and they would be making changes only to the container alication, just to make sure that they are showing the correct subapp in the correct part of the screen. Make sure that navigation works and stuff like that. We'll go into more on what the container's goal really is over time. Right now. Remember, we're just saying that's showing the other 2 applications. Now there is one other thing you want to make sure that's really, really clear, because you might be a little bit confused around the existence of these html files Ok, same diagram. I'm just a little bit lower, and I add on these red boxes. So just to make sure it's really clear, our products and car applications have indexhtml files inside them. Those html files are only used during the development of these sub projects. They're only used to load up products and cart and get them visible on the screen of the browser. So inside of any kind of production environment, we do not make use of the html files inside of products or cart. Instead, we load up the javascript only from products in cart into our container. And so ultimately, it is the html file inside of container that will be used during production. So again, we only really worry about the html files in product and cart during development. And for that reason, those html files are usually going to be very, very simple and very sparse. We're not going to really have a lot of markup in them. In general, we're just going to have some kind of root element where we can render our application into. Then we just make sure that our app works as expected. Okay, so hopefully this entire development process is just a little bit more clear now. And there is just one or two more changes, and other topics I want to go into in this application. So click ause a little bit more
